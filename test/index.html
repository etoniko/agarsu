<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="description"content="agar.su - захватывающая онлайн-игра, где вам предстоит выживать, поглощая других игроков и избегая опасных врагов. Боритесь за лидерство и испытайте свои навыки!">
<meta name="keywords"content="игры, game, браузерная игра, агарио, agario, онлайн игра, клетка, выживание, agar.io">
<meta name="author" content="Agar.su Team">
<meta name="robots" content="index, follow">

<!-- Open Graph для социальных сетей -->
<meta property="og:title" content="Agar.su - захватывающая браузерная игра">
<meta property="og:description" content="Играйте в agar.su — мир клеток, где нужно выживать, поглощая других игроков и избегая опасностей.">
<meta property="og:image" content="https://i.imgur.com/aUnAuZ0.jpg">
<meta property="og:url" content="https://agar.su">
<meta property="og:type" content="website">

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<!-- Twitter Cards -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Agar.su - Браузерная онлайн-игра">
<meta name="twitter:description" content="Играйте в agar.su — поглотите других и боритесь за лидерство!">
<meta name="twitter:image" content="https://i.imgur.com/aUnAuZ0.jpg">

<!-- Подтверждение права на сайт -->
<meta name="yandex-verification" content="ae692c51c9b8486f">
<!-- Yandex Games SDK -->
<script src="https://sdk.games.s3.yandex.net/sdk.js"></script>

    <title>agar.su - Завоевание начинается!</title>

    <!-- Favicon и иконки для Apple устройств -->
    <link rel="apple-touch-icon" href="https://cdn.jsdelivr.net/gh/etoniko/agarsu/icon.svg/icon.svg">
    <link rel="icon" href="https://cdn.jsdelivr.net/gh/etoniko/agarsu/icon.svg" type="image/svg+xml">
<!-- Canonical URL -->
<link rel="canonical" href="https://agar.su">

    <!-- Шрифты и стили -->
    <link href="https://fonts.googleapis.com/css?family=Ubuntu:700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0&icon_names=new_releases" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

    <!-- Скрипты -->
    <script src="https://cdn.jsdelivr.net/gh/etoniko/agarsu/jquery.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/etoniko/agarsu/log.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/etoniko/agarsu/vector.js"></script>
    

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();
   for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
   k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(98838177, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true,
        webvisor:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/98838177" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->



<script type="text/javascript">
    (function(e, x, pe, r, i, me, nt){
    e[i]=e[i]||function(){(e[i].a=e[i].a||[]).push(arguments)},
    me=x.createElement(pe),me.async=1,me.src=r,nt=x.getElementsByTagName(pe)[0],me.addEventListener("error",function(){function cb(t){t=t[t.length-1],"function"==typeof t&&t({flags:{}})};Array.isArray(e[i].a)&&e[i].a.forEach(cb);e[i]=function(){cb(arguments)}}),nt.parentNode.insertBefore(me,nt)})
    (window, document, "script", "https://abt.s3.yandex.net/expjs/latest/exp.js", "ymab");

    ymab("metrika.98838177", "setConfig", {enableSetYmUid: true});
    ymab("metrika.98838177", "init"/*, {clientFeatures}, {callback}*/);
</script>

<!-- Yandex.RTB -->
<script>window.yaContextCb=window.yaContextCb||[]</script>
<script src="https://yandex.ru/ads/system/context.js" async></script>
</head>

<style>
   @import url("https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap");
:root {
	--vs-primary: 29 92 255;
  -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Safari */
     -khtml-user-select: none; /* Konqueror HTML */
       -moz-user-select: none; /* Old versions of Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome, Edge, Opera and Firefox */
}


/* Фон полупрозрачный */
#captcha-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5); /* Черный фон с прозрачностью */
  display: flex;
  justify-content: center; /* Центрируем по горизонтали */
  align-items: center; /* Центрируем по вертикали */
  z-index: 9999; /* Чтобы фон был поверх всех элементов */
}

/* Стили для CAPTCHA контейнера */
#captcha-container {
  z-index: 10000; /* Обеспечиваем, чтобы CAPTCHA была поверх фона */
}

#canvas {
    touch-action: none; /* Disable browser's default touch handling */
}
/*Dialog Styles*/
dialog {
	padding: 1rem 3rem;
	background: white;
	width: 400px;
	padding-top: 2rem;
	border-radius: 20px;
	border: 0;
	box-shadow: 0 5px 30px 0 rgb(0 0 0 / 10%);
	animation: fadeIn 1s ease both;
	&::backdrop {
		animation: fadeIn 0.5s ease both;
		background: rgb(0 0 0 / 40%);
		z-index: 2;
		backdrop-filter: blur(20px);
	}
	.x {
		filter: grayscale(1);
		border: none;
		background: none;
		position: absolute;
		top: 15px;
		right: 10px;
		transition: ease filter, transform 0.3s;
		cursor: pointer;
		transform-origin: center;
		&:hover {
			filter: grayscale(0);
			transform: scale(1.1);
		}
	}
	h2 {
		font-weight: 600;
		font-size: 2rem;
		padding-bottom: 1rem;
	}
	p {
		font-size: 1rem;
		line-height: 1.3rem;
		padding: 0.5rem 0;
		a {
			&:visited {
				color: rgb(var(--vs-primary));
			}
		}
	}
}

/*General Styles*/
button.primary {
	display: inline-block;
	font-size: 0.8rem;
	color: #fff !important;
	background: rgb(var(--vs-primary) / 100%);
	padding: 13px 25px;
	border-radius: 17px;
	transition: background-color 0.1s ease;
	box-sizing: border-box;
	transition: all 0.25s ease;
	border: 0;
	cursor: pointer;
	box-shadow: 0 10px 20px -10px rgb(var(--vs-primary) / 100%);
	&:hover {
		box-shadow: 0 20px 20px -10px rgb(var(--vs-primary) / 100%);
		transform: translateY(-5px);
	}
}
button:focus { outline: none; }

@keyframes fadeIn {
	from {
		opacity: 0;
	}
	to {
		opacity: 1;
	}
}
	
	
	
	
	body {
	font-family: Arial,sans-serif;
    padding: 0;
    margin: 0;
    overflow: hidden;
}


i:hover{
	cursor: pointer;
}

.play{width: 170px;color: #fff;background: #ff3f58;transition: background 0.3s ease;height: 29px;font-size: 15px;font-weight: 700;cursor: pointer;border: 1px solid transparent;border-radius: 4px;transition: ease filter, transform 0.5s;	}
.play:hover{background: #c4293d;transition: ease filter, transform 0.5s;transform: scale(1.05);}

.spec {
    color: #ffffff;
    border-radius: 20px;
    font-size: 12px;
    cursor: pointer;
    margin-left: -42px;
    background: #0e172c;
    height: 19px;
    padding: 4px;
	border: 0;
}

.photo-gallery {
display: flex;
    align-items: center;
    justify-content: center;

}

	
.top-players-header {
    text-align: center;
    font-family: 'ubuntu';
	padding-top: 7px;
    padding-bottom: 2px;
	font-size: 20px;
	text-shadow: 0px -1px 0px #000000, -1px 0px 0px #000000, 1px 0px 0px #000000, 0px 1px 0px #000000, 1px 1px 0px #000000, -1px -1px 0px #000000, -1px 1px 0px #000000, 1px -1px 0px #000000, 0px 2px 0px #000000;
    color: #ffffff;
}

#table-container {
    overflow-y: auto;
    margin-top: 5px;
}
#table-container::-webkit-scrollbar {
  width: 10px;
}



#table-container::-webkit-scrollbar-thumb {
  border-radius: 5px;
  background: silver;
}

.header-row {
display: flex;
    justify-content: space-around;
}


.crown {
    position: absolute;
    top: -10px; /* Поднимаем корону над скин */
    right: 50%; /* Центрируем корону относительно скина */
    transform: translateX(50%); /* Дополнительное центрирование короны */
    font-size: 24px; /* Увеличиваем размер короны */
    color: gold; /* Золотой цвет для короны */
    text-shadow: 0 0 5px #000; /* Тень для лучшей видимости на разных фонах */
}
/* Добавляем стили для топ-1, топ-2 и топ-3 игроков */
.top-player:nth-child(1) {
    color: #ffd700; /* Золотой цвет для топ-1 */
}
.top-player{
    display: flex;
    justify-content: space-around;
	}
	.cell{
		width: 100px;
	}
	.rank{
		width: 100px;
		margin-top: 10px;
	}
	.nick{
    width: 150px;
    margin-top: 10px;
    text-overflow: ellipsis;
    overflow: hidden;
    height: 20px;
	}
	.score{
		width: 100px;
		margin-top: 10px;
	}

.top-player:nth-child(2) {
    color: #2579e7;
}

.top-player:nth-child(3) {
    color: #fc6579; 
}

/* Стили для остальных игроков */
.Lednick{
    overflow: hidden;
    width: 150px;
    white-space: nowrap;
    text-overflow: ellipsis;
}
.skkinn {
    background-size: cover;
    border-radius: 100%;
    border: solid 2px;
	margin: 0px 15px 5px 21px;
}
.time{
	font-size: 11px !important;
	margin-top: 10px;
    color: #8e8e8e;
	width: 100px;
}
.update-time {
        float: right;
    color: #0000006e;
    font-family: 'Ubuntu';
    cursor: context-menu;
    font-size: 11px;
    padding-top: 5px;
    padding-right: 3px;
	    text-shadow: 0px -1px 0px #000000, -1px 0px 0px #000000, 1px 0px 0px #000000, 0px 1px 0px #000000, 1px 1px 0px #000000, -1px -1px 0px #000000, -1px 1px 0px #000000, 1px -1px 0px #000000, 0px 2px 0px #000000;
    color: #6c757d !important;
}
.gall{
    margin-bottom: 10px;
	justify-content: space-around;
}

.gallery {
  --s: 150px; /* control the size */
  --g: 10px;  /* control the gap */
  --f: 1.5;   /* control the scale factor */
  
  display: grid;
  gap: var(--g);
}
.gallery > li {
	list-style: none;
	    background-size: cover;
  width: 0;
  height: 0;
  min-height: 100%;
  min-width: 100%;
  object-fit: cover;
  cursor: pointer;
  filter: grayscale(80%);
  transition: .30s linear;
}

.gallery li:hover{
  filter: grayscale(0);
  width:  calc(var(--s)*var(--f));
  height: calc(var(--s)*var(--f));
}

.adminhref{
	outline:none;color: gold;text-decoration: none;
}
.adminhref:hover{
	border: 2px solid white;
  box-shadow: inset 0px 0px 81px 17px  green, 0px 0px 20px 4px green;
	transition: ease filter, transform 0.5s;
	font-size: 20px;
}

.officialnews{
	text-align: center;margin-bottom: 5px;font-family: 'Ubuntu';margin-top: 10px;text-shadow: 0px -1px 0px #000000, -1px 0px 0px #000000, 1px 0px 0px #000000, 0px 1px 0px #000000, 1px 1px 0px #000000, -1px -1px 0px #000000, -1px 1px 0px #000000, 1px -1px 0px #000000, 0px 2px 0px #000000;color: #ffffff !important;font-size: 20px;
}
.officialnewss{
	padding-left: 20px;overflow: auto;margin-bottom: 0px;margin-top: 0px;padding-right: 10px;height:375px;font-family: 'Ubuntu';font-size: smaller;padding-top: 10px;text-shadow: 0px -1px 0px #000000, -1px 0px 0px #000000, 1px 0px 0px #000000, 0px 1px 0px #000000, 1px 1px 0px #000000, -1px -1px 0px #000000, -1px 1px 0px #000000, 1px -1px 0px #000000, 0px 2px 0px #000000;color: #6c757d !important;
}
#connecting{
	position: absolute; z-index: 1; display: block;
}
.conn{
	width: 250px;background-color: rgb(48 48 48 / 1);border-radius: 5px;padding-left: 10px;padding-right: 10px;padding-top: 10px;padding-bottom: 10px;height: 165px;
}
.connn{
	text-align: center;text-shadow: 0px -1px 0px #000000, -1px 0px 0px #000000, 1px 0px 0px #000000, 0px 1px 0px #000000, 1px 1px 0px #000000, -1px -1px 0px #000000, -1px 1px 0px #000000, 1px -1px 0px #000000, 0px 2px 0px #000000;color: #ffffff !important;font-size: 20px;
}
.connnn{
	position: absolute;margin-left: auto;margin-right: auto;left: 0;right: 0;top: 0;
}
.setting{
	color:white;position: absolute;padding-left: 10px;padding-top: 15px;
}

.agariosu{
	text-align: center;font-family: 'Ubuntu';padding-top: 30px;font-size: 30px;text-shadow: 0px -1px 0px #000000, -1px 0px 0px #000000, 1px 0px 0px #000000, 0px 1px 0px #000000, 1px 1px 0px #000000, -1px -1px 0px #000000, -1px 1px 0px #000000, 1px -1px 0px #000000, 0px 2px 0px #000000;color: #ffffff !important;
}
.version{
	text-align: center;font-size: 10px;top: 65px;left: 138px;color: #fffffff0;font-family: 'Ubuntu';padding-bottom: 10px;padding-top: 2px;text-shadow: 0px -1px 0px #000000, -1px 0px 0px #000000, 1px 0px 0px #000000, 0px 1px 0px #000000, 1px 1px 0px #000000, -1px -1px 0px #000000, -1px 1px 0px #000000, 1px -1px 0px #000000, 0px 2px 0px #000000;color: #e4c719 !important;
}
.st{
	display: flex;justify-content: center;
}

#skins{
	width:1000px;padding-right: 0px;padding-left: 0px;padding-top: 0px;padding-bottom: 0px;overflow: hidden;height: 550px;background: rgb(48 48 48 / 1);
}
.opsn{
	padding-left: 37px;margin-bottom: 0px;padding-bottom: 0px;text-shadow: 0px -1px 0px #000000, -1px 0px 0px #000000, 1px 0px 0px #000000, 0px 1px 0px #000000, 1px 1px 0px #000000, -1px -1px 0px #000000, -1px 1px 0px #000000, 1px -1px 0px #000000, 0px 2px 0px #000000;color: #ffffff !important;font-size: larger;margin-top: 20px;
}
.butt{
	display: flex;padding-top: 10px;justify-content: center;padding-bottom: 15px;
}
.adv{
text-align: center;font-family: 'Ubuntu';padding-top: 13px;text-shadow: 0px -1px 0px #000000, -1px 0px 0px #000000, 1px 0px 0px #000000, 0px 1px 0px #000000, 1px 1px 0px #000000, -1px -1px 0px #000000, -1px 1px 0px #000000, 1px -1px 0px #000000, 0px 2px 0px #000000;color: #ffffff !important;
}

.soc{
	color: white;
	cursor: default !important;
}
.tg{
	color:#006cf1;
transition: ease filter, transform 0.5s;
}
.tg:hover{
	color:#035dcb;
	transform: scale(1.1);
	transition: ease filter, transform 0.5s;
}

.chat-message {
  margin-bottom: 5px;
}

.chat-skin {
    width: 50px;
    height: 50px;
    background-size: cover;
    border: solid 2px white;
    border-radius: 50%;
}

.chat-name {
  font-weight: bold;
}
.chat-time{
    font-size: 10px;
    color: #8e8e8e;
    position: absolute;
    right: 10px;
}
.chat-text {
  color: #ffffff;
  font-family: arial;
  font-size: 16px;
}
#chat-container {
width: 290px;
    max-height: 300px;
    overflow-y: auto;
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    scroll-behavior: smooth;
}
	#chat_textbox {
transition: all .5s ease-in-out;
    background: rgb(133 133 133 / 20%);
    border: solid 1px #ffffff3d;
    outline: none;
    color: #ffffff;
    height: 30px;
    text-indent: 12px;
    width: 100%;
    border-radius: 20px;
}



.scoreshint{
    border: 0px solid #d3d3d357;
    padding: 5px;
    background-color: #80808057;
    border-radius: 0px 10px 10px 10px;
    padding-bottom: 8px;
    padding-left: 9px;
    position: relative;
    margin-bottom: 0px;
    overflow-wrap: anywhere;
    width: 227px;
    display: flex;
    flex-direction: column;
	margin-bottom: 10px;
	margin-right: 3px;
}
.scoreshint:after {
content: "";
    border: solid transparent;
    position: absolute;
    right: 100%;
    top: 0px;
    border-right-color: #80808057;
    border-width: 0px 13px 9px 0;
}

/* Убираем полосу прокрутки */
::-webkit-scrollbar {
    width: 3px; /* Для вертикальной полосы */
    height: 0; /* Для горизонтальной полосы */
}

/* Добавляем стили для индикации прокрутки */
::-webkit-scrollbar-thumb {
    background-color: #ffffff3b;
    border-radius: 10px; /* Закругленные углы */
}

/* Задаем стиль для области прокрутки */
::-webkit-scrollbar-track {
    background: transparent; /* Прозрачный фон для области прокрутки */
}


.add-left{
width: 240px;
    height: 400px;
    position: absolute;
    left: 2%;
    display: flex;
    align-items: center;
}
.add-right{
width: 240px;
    height: 400px;
    position: absolute;
    right: 2%;
    display: flex;
    align-items: center;
}
.add-top{
    width: 820px;
    position: absolute;
    height: 120px;
    top: 20px;
}
.add-bottom{
    width: 820px;
    position: absolute;
    height: 120px;
    bottom: 20px;
}
@media (max-height: 720px) {
  .add-top, .add-bottom {
    transform: scale(0.7);
  }
}

@media (max-width: 1400px) {
  .add-left, .add-right {
    transform: scale(0.7);
  }
}

@media (max-width: 599px) {
	.score-info{left: 40%;}
	#table-container {height: 375px;}
	.skkinn {height: 32px; width: 50px;}
.overchat{
transform: scale(0.7) translate(-7px, 7px);
transform-origin: bottom left;
}
.add-left{
display: none !important;
}
.add-top{
display: none !important;
}
.add-bottom{
display: none !important;
}
  .social {
position: absolute !important;
width: 140px !important;
height: 40px !important;
background: #0e172c !important;
font-size: 25px !important;
display: flex !important;
align-items: center !important;
justify-content: center !important;
flex-direction: row !important;
gap: 10px !important;
border-radius: 25px 25px 0 0 !important; /* Скругление: сверху слева и справа */
border: #ffffff14 solid 1px !important;
border-bottom: none !important; /* Убираем нижнюю границу */
left: 50% !important;
transform: translateX(-50%) !important; /* Центрирование по горизонтали */
bottom: 0px !important;
	}
    .sidebar {
        background-color: #016bef;
        display: flex;
        user-select: none;
        justify-content: space-evenly;
        align-items: center;
        width: 100%;
		border-radius: 0px 0px 25px 25px;
		padding: 0px 25px 0px 25px;
    }
    .sidebar .menu-item {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
	  flex-direction: column;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
	  padding: 5px;
    }
	    /* Main Content */
    .main-content {
        width: 100%;
        background-color: #0e172c;
        border-radius: 25px 25px 0px 0px;
        border: #ffffff14 solid 1px;
        height: 100%;
		padding: 20px 5px 0px 5px;
    }
	.center {
  z-index: 3;
  padding: 5px;
  flex-direction: column-reverse;
  display: flex;
  align-items: center;
  justify-content: center;
  height: 530px;
  width: 100%;
}
	.overlays{
		z-index: 1;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.6);
-webkit-backdrop-filter: blur(20px);
backdrop-filter: blur(20px);
	display: flex;
    align-items: center;
	}
	    .sidebar .menu-item i {
      font-size: 18px;
	  padding: 5px;
    }
    .sidebar .menu-item .label {
      font-size: 11px;
    }
	    .sidebar .menu-item.active {
      background-color: #171717;
	  border-bottom: solid;
    }
		    .avatar-containers {
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
	  margin-top: 40px;
    }
	#process{
    margin-top: 10px;
}
	.gallery {
		width: 100%;
		height: 390px;
    aspect-ratio: 4 / 6;
    grid-template-columns: repeat(4, auto);
}
#leaderboard{
	max-width: 140px !important;
    right: 5px;
    top: 5px;
    font-size: 11px;
}
}


@media (min-width: 600px) and (max-width: 899px) {
	.center {transform: scale(0.7);}
  .social {opacity: 0;}
  #leaderboard{display: none !important;}
.overchat{
transform: scale(0.5) translate(-5px, 5px);
transform-origin: bottom left;
}
}

    /* Base Reset */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Roboto', sans-serif;
      display: flex;
      height: 100%;
      width: 100%;
      background-color: #0e172c;
      color: white;
      overflow: hidden;
      touch-action: manipulation;
    }
	@media (min-width: 600px) { 
		.score-info{left: 50%;}
		#table-container {height: 340px;}
		.skkinn {height: 50px; width: 50px;}
    /* Sidebar */
    .sidebar {
      width: 100px; /* Fixed width to match the image */
      background-color: #016bef;
      display: flex;
      flex-direction: column;
      align-items: center;
	  justify-content: space-evenly;
	  height: 100%;
	  user-select: none;
	  border-radius: 25px 0 0 25px;
    }
    .sidebar .menu-item {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
	  flex-direction: column;
      color: white;
      font-size: 18px;
      cursor: pointer;
      transition: background-color 0.3s;
	  gap: 5px;
	  padding: 10px;
    }
	    /* Main Content */
    .main-content {
      height: 430px;
      width: 820px;
      padding: 20px;
      background-color: #0e172c;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
      position: relative;
	  height: 100%;
	  border-radius: 0px 25px 25px 0px;
	  border: #ffffff14 solid 1px;
      border-left: none;
    }
	 .center {
      display: flex;
      align-items: center;
      justify-content: center;
       height: 430px;
       width: 820px;
}
	.overlays{
		z-index: 1;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
	display: flex;
    align-items: center;
    justify-content: center;
	}
	    .sidebar .menu-item i {
      font-size: 20px;
    }
    .sidebar .menu-item .label {
      font-size: 16px;
    }
	    .sidebar .menu-item.active {
      background-color: #171717;
	  border-right: solid;
    }
	.main-skin {margin: 0 10px;}
	    .avatar-containers {
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
	  margin-top: 20px;
    }
		.gallery {
			width: 680px;
    aspect-ratio: 2;
    grid-template-columns: repeat(6, auto);
}
#leaderboard{
    right: 10px;
    top: 10px;
    font-size: 14px;
}
}

    .content {
      display: none;
      text-align: center;
    }
    .content.active {
      display: block;
      width: 100%;
    }
    /* Top Info Bar */
    .top-info {
    display: flex;
    justify-content: center;
    font-size: 18px;
	margin-bottom: 5px;
    }
    .top-info div {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .top-info span {
      background-color: #1b263b;
      padding: 8px 15px;
      border-radius: 20px;
    }
#process{
    font-size: 13px;
	color: #8e8e8e;
}

    /* Navigation Buttons */
    .nav-buttons {
      display: flex;
      gap: 20px;
      margin-top: 20px;
	  justify-content: center;
    }
    .nav-button {
      background-color: white;
      color: #016bef;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 10px;
	  border: 0;
    }
	.spec:hover{
		transform: scale(1.1);
	}
	.serv-button:hover{
      background-color: #016bef;
      color: white;
	}
    .play-button {
      background-color: #016bef;
      color: white;
    }
	    .play-button:hover {
      background-color: white;
      color: #016bef;
    }
	
	.input-container {
    position: relative; /* Для абсолютного позиционирования вложенного поля */
    width: 190px; /* Общая ширина контейнера */
}

.input-container input {
    box-sizing: border-box; /* Учитывать отступы и границы в ширине */
    outline: none; /* Убирает обводку при фокусировке */
}
input{
	font-size: 16px;
}

#nick {
    width: 190px; /* Длина поля для ника */
    padding-right: 70px; /* Отступ справа для поля пароля */
    margin-top: 20px;
    outline: none; /* Убирает обводку при фокусировке */
    border: 1px solid #ccc; /* Пример рамки, вы можете настроить цвет и стиль */
    border-radius: 20px; /* Добавляет округлость углов */
	height: 30px;
	padding-left: 8px;
}

#pass {
    position: absolute; /* Абсолютное позиционирование */
    top: 0; /* Положение сверху */
    right: 0; /* Положение справа */
    width: 80px; /* Длина поля для пароля */
    display: none; /* Изначально скрыто */
    margin-top: 20px;
	 border: 1px solid #ccc; /* Пример рамки, вы можете настроить цвет и стиль */
     border-radius: 0 20px 20px 0;
	 height: 30px;
	 padding-left: 5px;
	
}

#skinss {
    width: 150px;
    height: 150px;
    background-size: cover;
    border-radius: 100%;
    cursor: pointer;
    background-image: url(https://i.imgur.com/4tui4GP.png);
    transition: ease filter, transform 0.5s;
	border: solid;
}


/* Стили для контейнера скинов */
.avatar-container {
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
}



/* Стили для полупрозрачных предыдущих скинов */
.previous-skin, .next-skin {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background-size: cover;
    background-position: center;
    opacity: 0.5;
    transition: transform 0.3s ease, opacity 0.3s ease;
    cursor: pointer;
}

.previous-skin:hover, .next-skin:hover {
    transform: scale(1.1);
    opacity: 0.8;
}

/* Стили для стрелок */
.arrow {
    font-size: 24px;
    cursor: pointer;
    color: #0d84fb;
    user-select: none;
    padding: 5px;
}

.arrow:hover {
    color: #0073e6;
}
/* Scaling animation for the main skin */
.scale-down {
    transform: scale(0.9);
    transition: transform 0.3s ease;
}

.social{
position: absolute;
    width: 70px;
    height: 170px;
    background: #0e172c;
    right: 0;
    font-size: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 10px;
    border-radius: 25px 0 0 25px;
    border: #ffffff14 solid 1px;
    border-right: none;
}
.checkbox-container{
display: flex;
    flex-direction: column;
    align-items: flex-start;
}
#leaderboard{
	max-width: 160px;
position: absolute;
    padding: 10px 10px 10px 10px;
    border-radius: 20px 20px 20px 20px;
    border: solid #ffffff26 1px;
    background: rgba(0, 0, 0, .3);
}
.homemenu{
    position: absolute;
    top: 10px;
    left: 10px;
	padding: 7px;
    border-radius: 50%;
    font-size: 15px;
	color: #fff;
    border: solid #ffffff26 1px;
    background: rgba(0, 0, 0, .3);
}

.score-info{
position: absolute;
font-size: 12px;
display: flex;
transform: translate(-50%);
top: 10px;
gap: 5px;
}

.scorr{
	padding: 5px 10px 5px 10px;
    border-radius: 20px 20px 20px 20px;
    border: solid #ffffff26 1px;
    background: rgba(0, 0, 0, .3);
}
.cell-length{
    background: #1a73e8;
    padding: 0px 4px 0px 4px;
    height: 11px;
    border-radius: 10px 10px 10px 10px;
    font-size: 8px;
    margin-left: -13px;
}




.server-containers {
	border-radius: 25px;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: fixed;
    width: 350px;
    z-index: 1000;
    transition: height 0.3s ease, transform 0.3s ease;
    height: 0px;
	color: black;
	align-items: center;
}

.server-containers.visible {
    height: 200px;
    transform: translateX(0);
}

.avatar-container {
    transition: opacity 0.3s ease; /* Плавный переход для opacity */
}

.avatar-container.hidden {
    opacity: 0; /* Скрываем элемент */
}

.avatar-container.visible {
    opacity: 1; /* Показываем элемент */
}
.input-container {
    transition: opacity 0.3s ease; /* Плавный переход для opacity */
}

.input-container.hidden {
    opacity: 0; /* Скрываем элемент */
}

.input-container.visible {
    opacity: 1; /* Показываем элемент */
}
.sgm, .photo-gallery {
    opacity: 0; /* Изначально скрыто */
    transform: translateY(-20px); /* Начальная позиция для анимации */
    transition: opacity 0.1s ease, transform 0.1s ease; /* Переход для плавности */
}

.sgm.visible, .photo-gallery.visible {
    opacity: 1; /* Показываем элемент */
    transform: translateY(0); /* Возвращаем на место */
}

.sgm.hidden, .photo-gallery.hidden {
    opacity: 0; /* Скрываем элемент */
    transform: translateY(-20px); /* Сдвигаем вверх при исчезновении */
}

.scoreshint.admin {
  background: #b51e1e87;
}

.scoreshint.admin:after {
  border-right-color: #b51e1e87;
}

.scoreshint.admin .chat-name {
  color: gold;
  text-shadow: #FC0 1px 0 10px;
}
.fa-star{
	color: gold;
    text-shadow: #FC0 1px 0 10px;
}


.gamemode {
display: flex;
    align-items: center;
    justify-content: center;

}
.thumbnails {
    margin: 5px;
    width: 70px;
    font-weight: bold;
    padding-top: 85px;
    cursor: pointer;
    text-align: center;
    color: white;
    border-radius: 4px;
}
.thumbnail {
    margin: 5px;
    width: 70px;
    font-weight: bold;
    padding-top: 85px;
    cursor: pointer;
    text-align: center;
    color: white;
    border-radius: 4px;
}

.ffa {
background: #E2E2E2 url(https://i.imgur.com/J6RSops.png) top 20px center no-repeat;
background-size: 50px auto;
transition: ease filter, transform 0.5s;
}

.ffa:hover {
    background-color: #ff3f58;
	transition: ease filter, transform 0.5s;
	transform: scale(1.1);
}

.crazy {
    background: #E2E2E2 url(https://i.imgur.com/5J9FUmL.png) top 20px center no-repeat;
	transition: ease filter, transform 0.5s;
    background-size: 50px auto;
}

.crazy:hover {
    background-color: #00c1f1;
	transition: ease filter, transform 0.5s;
	transform: scale(1.1);
}

.teams {
    background: #E2E2E2 url(https://i.imgur.com/J8BL7ta.png) top -5px center no-repeat;
	transition: ease filter, transform 0.5s;
background-size: 50px auto;
}

/*.teams:hover {
    background-color: #ffaa00;
	transition: ease filter, transform 0.5s;
	transform: scale(1.1);
}*/

.exp {
	
    background: #E2E2E2 url(https://i.imgur.com/v7xO2Ta.png) top 20px center no-repeat;
	transition: ease filter, transform 0.5s;
    background-size: 50px auto;
}

/*.exp:hover {
    background-color: #1e67e0;
	transition: ease filter, transform 0.5s;
	transform: scale(1.1);
}*/

.thumbnail.ffa {
    --thumbnail-bg-color: #ff3f58; /* Цвет фона для FFA */
	transition: ease filter, transform 0.5s;
}

.thumbnail.crazy {
    --thumbnail-bg-color: #00c1f1; /* Цвет фона для crazy*/
}

/*.thumbnail.teams {
    --thumbnail-bg-color: #ffaa00; 
}*/

/*.thumbnail.exp {
    --thumbnail-bg-color: #1e67e0; 
}*/
.actives {
    background-color: var(--thumbnail-bg-color);
	transition: ease filter, transform 0.5s;
	transform: scale(1.1);
}
.sgm{padding-bottom: 10px;font-family: 'ubuntu';color: #ffffff;font-size: 20px;
}




.progress-container {
font-family: Arial, sans-serif;
    position: absolute;
    top: 21px;
}

.level-circle {
  width: 40px;
  height: 40px;
  background-color: white;
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  font-weight: bold;
  font-size: 14px;
  color: black;
  position: absolute;
}

.progress-bar {
    width: 220px;
    height: 37px;
    background-color: #1b263b;
    border-radius: 20px;
    overflow: hidden;
    display: flex;
    align-items: center;
}

.progress-fill {
  height: 100%;
  background-color: #016bef; /* Синий цвет */
  border-radius: 20px 0 0 20px;
}

.progress-text {
  position: absolute;
  width: 100%;
  text-align: center;
  color: white;
  font-size: 14px;
  font-weight: bold;
  pointer-events: none;
}


#accountID{
    position: absolute;
    right: 20px;
    top: 20px;
    background-color: #1b263b;
    padding: 9.5px 15px;
    border-radius: 20px;
}
        .line {
    width: 100%;
    height: 2px;
    background-color: #ffffff;
    margin: 10px 0px 10px 0px;
}

#l1eaderboard {
    max-width: 150px;
    position: absolute;
    padding: 10px 10px 10px 10px;
    border-radius: 20px 20px 20px 20px;
    border: solid #ffffff26 1px;
    background: rgba(0, 0, 0, .3);
}

        .star-container {
			font-size: 20px; /* Размер звезды */
            position: relative;
            display: inline-block;
        }

        .levelme {
position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 10px;
    color: #6a6a6a;
    font-family: 'Ubuntu';
        }

.overchat {
    position: absolute;
    bottom: 10px;
    max-height: 450px;
    width: 310px;
    left: 10px;
    padding: 10px 10px 10px 10px;
    border-radius: 20px 20px 20px 20px;
    border: solid #ffffff26 1px;
    background: rgba(0, 0, 0, .3);
}

.overchat.hidden {
    width: 43px;
}

#toggleChatButton {
background: none;
    border: none;
    cursor: pointer;
    font-size: 18px;
    color: white;
    float: right;
    padding: 0px 5px 5px 0px;
}

#serverclose-overlay{
display: none;
position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
}


        #serverclose {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #0e172c;
    color: #ff0000d6;
    text-shadow: #ff0000d6 1px 0 10px;
    padding: 20px;
    border-radius: 25px;
    text-align: center;
    border: #ffffff14 solid 1px;
        }

        #serverclose i {
            font-size: 2em; 
            margin-bottom: 10px; 
            animation: spin 2s linear infinite; 
            display: block; 
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #countdown {
            font-size: 1.2em;
            margin-top: 10px;
        }
</style>
<body>
<!-- Yandex.RTB R-A-15699059-6 -->
<script>
window.yaContextCb.push(() => {
    Ya.Context.AdvManager.render({
        "blockId": "R-A-15699059-6",
        "type": "fullscreen",
        "platform": "touch"
    })
})
</script>
<style>
#staticks {
  position: absolute; /* Теперь относительно #game-container */
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background-color: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 20px;
  border-radius: 10px;
  font-family: sans-serif;
  font-size: 20px;
  text-align: center;
  z-index: 1000;
  border: 2px solid white;
  box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
  display: none;
}
</style>
  <div id="staticks">
    <h2>Game Over!</h2>
<canvas id="myChart"></canvas>
<script>
  const scoreElement = document.getElementById('score-new');
  const dataPoints = [];
  const labels = [];
  let chart;

  const updateInterval = 1000; // milliseconds (adjust as needed)
  const maxDataPoints = 20; // Maximum number of data points to keep

  function updateChart() {
    const scoreText = scoreElement.innerText;
    const score = parseInt(scoreText.replace('Сейчас: ', '')); // Extract number
    if (isNaN(score)) {
      console.warn("Could not parse score value.");
      return; // Don't add if parsing fails
    }

    const currentTime = new Date().toLocaleTimeString();
    dataPoints.push(score);
    labels.push(currentTime);

    // Keep only the last 'maxDataPoints' data points
    if (dataPoints.length > maxDataPoints) {
      dataPoints.shift();
      labels.shift();
    }

    console.log("Score:", score, "Time:", currentTime); // Debugging

    if (chart) {
      chart.data.datasets[0].data = dataPoints;
      chart.data.labels = labels;
      chart.update();
    } else {
      // Initialize chart on first data point
      const ctx = document.getElementById('myChart').getContext('2d');
      chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [{
            label: 'Score',
            data: dataPoints,
            borderColor: 'rgb(75, 192, 192)',
            tension: 0.1
          }]
        },
        options: {
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });
    }
  }

  // Initial call to start the process
  updateChart();
  setInterval(updateChart, updateInterval);


</script>
  </div>
    <div id="overlays" class="overlays">
      <!--<div class="social">
         <a href="https://t.me/agarsu" target="_blank" class="tg"><i
                 style="background: radial-gradient(white 9px, #1e90ff00 50%);border-radius: 50%;" class="fab fa-telegram"></i></a>
         <a href="#" class="soc"><i style="cursor: not-allowed;" class="fab fa-vk"></i></a>
         <a href="#" class="soc"><i style="cursor: not-allowed;" class="fab fa-discord"></i></a>
     </div>-->
<div class="add-left">
<!-- Yandex.RTB R-A-15699059-8 -->
<div id="yandex_rtb_R-A-15699059-8"></div>
<script>
window.yaContextCb.push(() => {
    Ya.Context.AdvManager.render({
        "blockId": "R-A-15699059-8",
        "renderTo": "yandex_rtb_R-A-15699059-8"
    })
})
</script>
</div>
<div class="add-right">
</div>
<div class="add-top">
</div>
<div class="add-bottom">
</div>
        <div class="center">
            <div class="sidebar">
                <div class="menu-item" onclick="showContent('profile')">
                    <i class="fas fa-gear"></i>
                    <span class="label">Настройки</span>
                </div>
                <div class="menu-item" onclick="showContent('skinslist')">
                    <i class="fas fa-image"></i>
                    <span class="label">Скины</span>
                </div>
                <div class="menu-item active" onclick="showContent('home')">
                    <i class="fas fa-home"></i>
                    <span class="label">Главная</span>
                </div>
                <div class="menu-item" id="sst" onclick="showContent('rating')">
                    <i class="fas fa-star"></i>
                    <span class="label">Рейтинг</span>
                </div>
                <script>
                    document.getElementById('sst').addEventListener('click', function () {
                        chekstats();
                    });
                </script>
                <div class="menu-item" onclick="showContent('store')">
                    <i class="fas fa-user"></i>
                    <span class="label">Войти</span>
                </div>
            </div>

            <!-- Main Content -->
            <div class="main-content">
                <div id="profile" class="content">
                    <div class="top-info">
                        <div><span>Настройки</span></div>
                    </div>
<div class="checkbox-container">
     <label><input type="checkbox" class="save" data-box-id="2" onchange="setNames(!$(this).is(':checked'));">Оключить Имена</label>
     <label><input type="checkbox" class="save" data-box-id="4" onchange="setColors($(this).is(':checked'));">Без Цветов</label>
     <label><input type="checkbox" class="save" data-box-id="5" onchange="setShowMass($(this).is(':checked'));" checked>Показать Массу</label>
     <label><input type="checkbox" class="save" data-box-id="6" onchange="setSmooth($(this).is(':checked'));">Простой Рендер</label>
     <label><input type="checkbox" class="save" data-box-id="7" onchange="setChatHide($(this).is(':checked'));">Отключить Чат</label>
     <label><div id="theme-selector"><label>Выберите тему:</label><select id="theme-select"><option value="gradient">Градиент</option><option value="white">Белая</option><option value="black">Черная</option></select></div></label>
 </div>
                </div>
                <div id="skinslist" class="content">
                    <div style="display: flex;flex-direction: column;justify-content: space-around;" class="top-info">
                        <div class="gall"><span>Скины</span></div>
                        <ul class="gallery">
                            <li style="background-image: url('https://i.imgur.com/tq33YWv.png');"
                                onclick="selectSkin('Муха');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/dzQIxk0.png');"
                                onclick="selectSkin('Паук');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/fpDpEl9.png');"
                                onclick="selectSkin('Кактус');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/69ChrNV.png');"
                                onclick="selectSkin('Зая');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/qRq5CIg.png');"
                                onclick="selectSkin('Оса');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/TPgKn6V.png');"
                                onclick="selectSkin('Ящерица');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/QPCVdvQ.png');"
                                onclick="selectSkin('Лиса');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/YbmC0tv.png');"
                                onclick="selectSkin('Волк');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/hmVJPmb.png');"
                                onclick="selectSkin('Мамонт');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/RKtDpin.png');"
                                onclick="selectSkin('Динозавр');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/3hxdGAq.png');"
                                onclick="selectSkin('Мороженое');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/zdcHEFS.png');"
                                onclick="selectSkin('Ракета');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/roUvNMV.png');"
                                onclick="selectSkin('Могучая');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/57BzylL.png');"
                                onclick="selectSkin('Фаун');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/rPlbHK7.png');"
                                onclick="selectSkin('Бабушка');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/ruAUEpb.png');"
                                onclick="selectSkin('Гора');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/ipqCMMf.png');"
                                onclick="selectSkin('Космонавт');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/wRiL4Jx.png');"
                                onclick="selectSkin('Первобытный');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/GTxoIhj.png');"
                                onclick="selectSkin('Влюблённый');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/EcW6zbE.png');"
                                onclick="selectSkin('Влюблённая');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/UINxrlJ.png');"
                                onclick="selectSkin('Самба');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/lxAXnAi.png');"
                                onclick="selectSkin('Снеговик');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/7GWqCnY.png');"
                                onclick="selectSkin('Панда');showContent('home')"></li>
                            <li style="background-image: url('https://i.imgur.com/4faALdC.png');"
                                onclick="selectSkin('Теннисистка');showContent('home')"></li>
                        </ul>

                    </div>
                </div>
                <!-- Home Content -->
                <div id="home" class="content active">
                    <div class="top-info">
                        <div><span>agar.su</span></div>
                    </div>
                    <div>
					<div class="line"></div>
                        <span id="process">Онлайн☹️: 0</span>
                        <span id="userXP"></span>
                        <span id="userLevel"></span>
                    </div>
<div class="progress-container">
  <div class="progress-bar">
    <div class="level-circle" id="levelCircle">0</div>
    <div class="progress-fill"></div>
    <div class="progress-text" id="progressText">0% (0/0)</div>
  </div>
</div>
<span id="accountID">ID: 0000</span>

                    <script>
                        async function updateOnlineCount() {
                            try {
                                const response = await fetch('https://itana.pw:6001/process'); // Запрос к серверу по /process
                                if (response.ok) {
                                    const data = await response.json(); // Преобразуем ответ в JSON
                                    document.getElementById('process').textContent = `Онлайн: ${data.online}`; // Обновляем текст в div
                                } else {
                                    console.error('Ошибка при получении данных:', response.status);
                                }
                            } catch (error) {
                                console.error('Произошла ошибка:', error);
                            }
                        }

                        updateOnlineCount();
                    </script>
                    <div class="avatar-containers">
                        <div class="avatar-container">
                            <div class="previous-skin" id="prevSkin" onclick="showPrevious()"></div>
                            <div class="arrow" id="previous" onclick="showPrevious()">&#10094;</div>
                            <div onclick="showContent('skinslist')" id="skinss" class="main-skin"></div>
                            <div class="arrow" id="next" onclick="showNext()">&#10095;</div>
                            <div class="next-skin" id="nextSkin" onclick="showNext()"></div>
                        </div>
                        <!-- Новый элемент сервера -->
                        <div id="server" class="server-containers" style="display: none;">
                            <div class="sgm">Выбери себе режим!</div>
                            <div class="gamemode">
                                <div class="thumbnail ffa actives" onclick="setserver('itana.pw:6001');">ФФА</div>
                                <div class="thumbnail crazy" onclick="setserver('itana.pw:6002');">КРЕЗИ</div>
                                <div style="cursor: not-allowed;opacity: 0.6;" class="thumbnails teams">ТИМА</div>
                                <div style="cursor: not-allowed;opacity: 0.6;" class="thumbnails exp">ЕКСП</div>
                                <script>
                                    function updateActiveThumbnail() {
                                        const hash = window.location.hash.substring(1);
                                        const thumbnails = document.querySelectorAll('.thumbnail');

                                        // Remove active from all
                                        thumbnails.forEach(el => el.classList.remove('actives'));

                                        // Add active based on hash, fallback to FFA
                                        const activeThumbnail = Array.from(thumbnails).find(el => el.classList.contains(hash)) || document.querySelector('.ffa');
                                        activeThumbnail.classList.add('actives');
                                    }

                                    // Initial check on page load
                                    updateActiveThumbnail();

                                    // Add event listener for hash changes
                                    window.addEventListener('hashchange', updateActiveThumbnail);


                                    // Add event listeners to thumbnails
                                    document.querySelectorAll('.thumbnail').forEach(item => {
                                        item.addEventListener('click', () => {
                                            //Remove active from all
                                            document.querySelectorAll('.thumbnail').forEach(el => el.classList.remove('actives'));

                                            //Add active to clicked
                                            item.classList.add('actives');

                                            //Update the URL hash
                                            window.location.hash = item.classList[1];
                                        });
                                    });
                                </script>
                            </div>
                        </div>
                        <div class="input-container">
                            <form>
                                <input type="text" placeholder="Ник" name="name" maxlength="15" id="nick" required
                                    autocomplete="username" />
                                <input type="password" placeholder="Пасс" name="pass" id="pass" required
                                    autocomplete="current-password" />
                            </form>
                        </div>
                    </div>

                    <script>
                        // Переменные для отслеживания действий
                        let lastActionTime = 0; // Время последнего действия
                        const actionInterval = 500; // Интервал между действиями (в мс)
                        let actionTimeout; // Таймер для обработки ввода
                        let currentIndex = 0; // Индекс текущего игрока

                        // Функция загрузки списка скинов
                        async function loadSkinsList() {
                            const response = await fetch('https://raw.githubusercontent.com/etoniko/agarsu/refs/heads/main/skinlist.txt');
                            const data = await response.text();
                            const skinsMap = new Map();

                            data.split('\n').forEach(line => {
                                const [nick, id] = line.split(':');
                                if (nick && id) skinsMap.set(nick.trim().toLowerCase(), id.trim());
                            });
                            return skinsMap;
                        }

                        // Функция нормализации ника для поиска
                        function normalizeNick(nick) {
                            return nick.trim().toLowerCase();
                        }

                        // Функция выбора скина и сохранения данных игрока в localStorage
                        async function selectSkin(nick) {
                            const skinsMap = await loadSkinsList();
                            const normalizedNick = normalizeNick(nick);

                            // Проверка, если скин найден
                            if (skinsMap.has(normalizedNick)) {
                                const id = skinsMap.get(normalizedNick);

                                // Сохранение данных игрока в localStorage
                                savePlayerData(nick, id);
                                currentIndex = getCurrentPlayerIndex(nick); // Обновление индекса
                                updateAvatarDisplay(); // Обновление аватара
                            } else {
                                document.querySelector("#skinss").style.backgroundImage = ""; // Очистка фона
                            }
                        }

                        // Функция получения текущего индекса игрока из localStorage
                        function getCurrentPlayerIndex(nick) {
                            const players = JSON.parse(localStorage.getItem('players') || '[]');
                            return players.findIndex(player => normalizeNick(player.nick) === normalizeNick(nick));
                        }

                        // Функция сохранения данных игрока в localStorage
                        function savePlayerData(nick, id) {
                            const players = JSON.parse(localStorage.getItem('players') || '[]');
                            const playerData = { nick, id }; // Сохраняем ник и скин

                            // Удаление дубликатов
                            const index = players.findIndex(player => normalizeNick(player.nick) === normalizeNick(nick));
                            if (index !== -1) players.splice(index, 1);

                            // Добавление нового игрока в начало
                            players.unshift(playerData);

                            // Ограничение хранения последних 3 игроков
                            if (players.length > 3) players.pop();

                            localStorage.setItem('players', JSON.stringify(players)); // Сохранение в localStorage
                        }

                        // Функция обновления отображения аватаров
                        function updateAvatarDisplay() {
                            const players = JSON.parse(localStorage.getItem('players') || '[]');
                            const mainSkin = document.querySelector("#skinss");
                            const previousSkin = document.querySelector("#prevSkin");
                            const nextSkin = document.querySelector("#nextSkin");

                            // Очистка фонов
                            mainSkin.style.backgroundImage = "";
                            previousSkin.style.backgroundImage = "";
                            nextSkin.style.backgroundImage = "";

                            if (players.length > 0) {
                                const currentPlayer = players[currentIndex];
                                mainSkin.style.backgroundImage = `url(https://i.imgur.com/${currentPlayer.id}.png)`; // Выставляем скин
                                document.getElementById("nick").value = currentPlayer.nick;

                                // Установка предыдущего скина
                                const prevIndex = (currentIndex - 1 + players.length) % players.length;
                                if (players[prevIndex]) {
                                    previousSkin.style.backgroundImage = `url(https://i.imgur.com/${players[prevIndex].id}.png)`;
                                }

                                // Установка следующего скина
                                const nextIndex = (currentIndex + 1) % players.length;
                                if (players[nextIndex]) {
                                    nextSkin.style.backgroundImage = `url(https://i.imgur.com/${players[nextIndex].id}.png)`;
                                }
                            }
                        }

                        // Показ следующего игрока
                        function showNext() {
                            const players = JSON.parse(localStorage.getItem('players') || '[]');
                            if (players.length > 0) {
                                currentIndex = (currentIndex + 1) % players.length;
                                changeSkin();
                            }
                        }

                        // Показ предыдущего игрока
                        function showPrevious() {
                            const players = JSON.parse(localStorage.getItem('players') || '[]');
                            if (players.length > 0) {
                                currentIndex = (currentIndex - 1 + players.length) % players.length;
                                changeSkin();
                            }
                        }

                        // Анимация смены скина
                        function changeSkin() {
                            const mainSkin = document.querySelector("#skinss");
                            mainSkin.classList.add("scale-down");
                            setTimeout(() => {
                                updateAvatarDisplay();
                                mainSkin.classList.remove("scale-down");
                            }, 50);
                        }

                        // Обработчик ввода ника
                        document.getElementById('nick').addEventListener('input', function () {
                            const nickname = this.value;
                            clearTimeout(actionTimeout);
                            actionTimeout = setTimeout(async () => {
                                await selectSkin(nickname);
                            }, actionInterval);
                        });

                        // Загрузка сохранённых данных при загрузке страницы
                        window.addEventListener("load", function () {
                            const players = JSON.parse(localStorage.getItem('players') || '[]');

                            if (players.length > 0) {
                                currentIndex = 0;
                                updateAvatarDisplay();
                            }
                        });

                    </script>

                    <div class="nav-buttons">
                        <!--<span style="position: absolute;margin-right: 20px;color: #ffec0c;border-radius: 100%;background-image: linear-gradient(red, red);background-repeat:no-repeat;background-size: 14px 15px;background-position: center;" class="material-symbols-outlined">new_releases</span>-->
                        <div onclick="toggleServer();" class="nav-button serv-button"><i class="fas fa-server"></i>
                            СЕРВЕРА
                        </div>
                        <!-- change div -> button | Disabled button xxxevexxx -->
                        <button id="button-text" onclick="startGame(); return false;" class="nav-button play-button"><i
                                class="fas fa-play"></i> ИГРАТЬ</button>
<script>
                                                  let playButtonClickCount = 0; // Счётчик нажатий
                            let serverSet = false; // Флаг, чтобы вызвать setserver только один раз

                            async function startGame() {

                                setNick(document.getElementById('nick').value);

                                // Проверяем, инициализирован ли Yandex SDK, и запускаем геймплей
                                if (window.ysdk) {
                                    window.ysdk.features.GameplayAPI?.start();
                                    console.log("Геймплей начат");
                                } else {
                                    console.warn("SDK Яндекс Игр не инициализирован");
                                }

                                playButtonClickCount++; // Увеличиваем счётчик

                                const buttonText = document.getElementById("button-text");

                                if (playButtonClickCount === 2) {
                                }

                                if (playButtonClickCount === 3) {
                                    playButtonClickCount = 0; // Сбрасываем счётчик после третьего нажатия

                                    try {
                                        await window.ysdk.adv.showFullscreenAdv(); // Показ рекламы
                                        console.log("Реклама показана успешно");
                                    } catch (error) {
                                        console.error("Ошибка при показе рекламы:", error);
                                    } finally {
                                    }
                                }
                            }
                        </script>
                        <!-- change div -> button | Disabled button xxxevexxx -->
                        <button id="button-spec" class="spec" onclick="spectate();"><i class="fas fa-eye"></i>
                        </button>
                    </div>
                    <script>
                        let isServerOpen = false; // Переменная для отслеживания состояния сервера

                        function toggleServer() {
                            if (isServerOpen) {
                                closeServer();
                            } else {
                                openServer();
                            }
                        }

                        function openServer() {
                            const server = document.getElementById('server');
                            const avatarContainer = document.querySelector('.avatar-container');
                            const inputContainer = document.querySelector('.input-container');
                            const sgm = document.querySelector('.sgm');
                            const photoGallery = document.querySelector('.gamemode');

                            server.style.display = 'flex'; // Показать элемент сервера
                            requestAnimationFrame(() => {
                                server.classList.add('visible'); // Анимация появления сервера
                                sgm.classList.add('visible'); // Анимация появления sgm
                                photoGallery.classList.add('visible'); // Анимация появления photo-gallery
                            });

                            // Скрываем аватар и input-container
                            avatarContainer.classList.add('hidden');
                            inputContainer.classList.add('hidden');

                            isServerOpen = true; // Устанавливаем состояние сервера в открытое
                        }

                        function closeServer() {
                            const server = document.getElementById('server');
                            const avatarContainer = document.querySelector('.avatar-container');
                            const inputContainer = document.querySelector('.input-container');
                            const sgm = document.querySelector('.sgm');
                            const photoGallery = document.querySelector('.gamemode');

                            server.classList.remove('visible'); // Анимация исчезновения сервера
                            sgm.classList.remove('visible'); // Анимация исчезновения sgm
                            photoGallery.classList.remove('visible'); // Анимация исчезновения photo-gallery

                            server.addEventListener('transitionend', () => {
                                server.style.display = 'none'; // Скрыть сервер после завершения анимации
                            }, { once: true });

                            // Показываем аватар и input-container
                            avatarContainer.classList.remove('hidden');
                            inputContainer.classList.remove('hidden');

                            isServerOpen = false; // Устанавливаем состояние сервера в закрытое
                        }

                    </script>
                </div>
                <div id="rating" class="content">
                    <div class="top-info">
                        <div><span>Лучшие Игроки</span></div>
                    </div>
                    <div class="header-row">
                        <div class="cell">Время</div>
                        <div class="cell">Позиция</div>
                        <div class="cell">Ник</div>
                        <div class="cell">Масса</div>
                        <div class="cell">Скин</div>
                    </div>
                    <div id="table-container"></div>
                    <script>
                        // Функция для получения данных статистики
                        async function fetchStats(stats) { // Изменяем здесь, чтобы принимать stats
                            try {
                                // Убедимся, что stats переданы и являются массивом
                                if (!Array.isArray(stats)) {
                                    throw new Error('Invalid stats data');
                                }

                                const skinsMap = await loadSkinsList(); // Загрузка skinsList

                                // Обновляем каждый player в stats
                                stats.forEach(player => {
                                    const skinId = skinsMap.get(player.nick.toLowerCase()) || 'PPFtwqH'; // Используем nick напрямую для skinId
                                    player.skin = skinId; // Установка skin для игрока
                                });

                                displayStats(stats);
                            } catch (error) {
                                console.error('There was a problem with the fetch operation:', error);
                            }
                        }

                        // Функция для отображения статистики
                        function displayStats(stats) {
                            const container = document.getElementById('table-container');
                            container.innerHTML = ''; // Очищаем контейнер перед добавлением новых данных

                            stats.forEach((player, index) => {
                                const playerDiv = document.createElement('div');
                                playerDiv.classList.add('top-player');
                                playerDiv.innerHTML = `
            <div class="time">${player.time}</div> <!-- Добавлено время -->
            <div class="rank">${index + 1}</div>
            <div class="nick">${player.nick}</div>
            <div class="score">${player.score}</div>
            <div class="skkinn" style="background-image: url('https://i.imgur.com/${player.skin}.png');"></div>
        `;
                                container.appendChild(playerDiv);
                            });
                        }

                    </script>

                </div>
                <div id="store" class="content">
                    <div class="top-info">
                        <div><span>Кабинет</span></div>
                    </div>
                    <div class="header-row">
                        <button style="display:none" id="logoutButton" onclick="logoutAccount()">Выход</button>

                        <script src="//ulogin.ru/js/ulogin.js"></script>
                        <div id="loginButton" id="uLogin"
                            data-ulogin="callback=onUloginToken;display=panel;fields=photo,first_name,last_name;providers=vkontakte,odnoklassniki,mailru,facebook;hidden=other;redirect_uri=http%3A%2F%2Flocalhost%3A6969%2Fauth%2Fulogin">
                        </div>

                    </div>
                </div>
            </div>

            <script>
                function showContent(id) {
                    document.querySelectorAll('.menu-item').forEach(item => item.classList.remove('active'));
                    document.querySelectorAll('.content').forEach(content => content.classList.remove('active'));

                    document.querySelector(`.menu-item[onclick="showContent('${id}')"]`).classList.add('active');
                    document.getElementById(id).classList.add('active');
                }
            </script>
        </div>
    </div>

    <canvas id="canvas"></canvas>
    <script>
        // Получаем элементы канваса и div-элемента overlays
        var canvas = document.getElementById('canvas');
        var overlays = document.getElementById('overlays');

        // Добавляем слушатель события мыши на div-элемент overlays
        overlays.addEventListener('mousemove', function (event) {
            // Получаем позицию курсора относительно overlays
            var x = event.clientX - overlays.offsetLeft;
            var y = event.clientY - overlays.offsetTop;

            // Создаем событие мыши для канваса
            var canvasEvent = new MouseEvent('mousemove', {
                bubbles: true,
                cancelable: true,
                clientX: x,
                clientY: y
            });

            // Передаем событие канвасу
            canvas.dispatchEvent(canvasEvent);
        });

    </script>
<div class="overchat">
    <button id="toggleChatButton">
        <i class="fas fa-close"></i>
    </button>
    <div id="chat-container"></div>
    <input type="text" autocomplete="off" id="chat_textbox" maxlength="120" placeholder="Напишите сообщение...">
</div>
<script>
// Получаем элементы
const toggleChatButton = document.getElementById('toggleChatButton');
const chatContainer = document.getElementById('chat-container');
const chatTextBox = document.getElementById('chat_textbox');
const chatIcon = toggleChatButton.querySelector('i');
const overchatElement = document.querySelector("body > div.overchat"); // Получаем элемент overchat

// Начальное состояние чата (видимый)
let isChatVisible = true;

// Обработчик клика по кнопке
toggleChatButton.addEventListener('click', function() {
    if (isChatVisible) {
        // Если чат видимый, скрываем его с помощью высоты
        chatContainer.style.height = '0';
        chatTextBox.style.display = 'none'; // Скрываем текстовое поле
        chatIcon.classList.remove('fa-close');
        chatIcon.classList.add('fa-arrow-up');
        overchatElement.style.maxWidth = '43px'; // Устанавливаем max-width
    } else {
        // Если чат скрыт, показываем его
        chatContainer.style.height = 'auto';
        chatTextBox.style.display = 'block'; // Показываем текстовое поле
        chatIcon.classList.remove('fa-arrow-up');
        chatIcon.classList.add('fa-close');
        overchatElement.style.maxWidth = ''; // Сбрасываем max-width (применяется стиль по умолчанию)
    }

    // Переключаем состояние видимости чата
    isChatVisible = !isChatVisible;
});
</script>
    <div class="homemenu" onclick="$('#overlays').show();"><i class="fas fa-home"></i></div>


    <div class="score-info" id="score-info">
        <div class="scorr" id="score-max">0</div>
        <div class="scorr" id="score-new">0</div>
        <div class="cell-length" id="cell-length">0</div>
    </div>
    <div id="leaderboard"></div>
    <div id="serverclose-overlay">
    <div id="serverclose">
        <i class="fas fa-spinner fa-spin"></i> 
        <div>Соединение с сервером потеряно.</div>
        <div id="countdown">Перезагрузка через: 10</div>
    </div>
    </div>
</body>

<script>
(function (wHandle, wjQuery) {
    // Загружаем список скинов из skinList.txt
    var skinList = {};



 // Функция для проверки, что игра работает на платформе Яндекс Игр
    function isYandexGamesPlatform() {
        try {
            // Проверка, что родительский домен - это Яндекс Игры
            return window.location !== window.parent.location && document.referrer.includes('yandex');
        } catch (e) {
            return false;
        }
    }

    // Асинхронная функция для инициализации SDK Яндекс Игр
    async function initYandexSDK() {
        if (isYandexGamesPlatform()) {
            try {
                // Инициализация SDK Яндекс Игр
                const ysdk = await YaGames.init();
                console.log('Yandex SDK initialized');
                window.ysdk = ysdk;

                // Проверяем, доступен ли LoadingAPI и ожидаем, что он будет готов
                if (ysdk.features && ysdk.features.LoadingAPI) {
                    await ysdk.features.LoadingAPI.ready();
                    console.log('Платформа готова, игра может начаться');

                    // Показываем рекламу сразу после загрузки SDK
                    if (ysdk.adv) {
                        await ysdk.adv.showFullscreenAdv();
                        console.log('Реклама показана');
                    } else {
                        console.warn('Реклама недоступна');
                    }
                } else {
                    console.warn('LoadingAPI не доступен');
                }

            } catch (err) {
                console.error('Ошибка инициализации SDK Яндекс Игр:', err);
            }
        } else {
            console.warn('SDK Яндекс Игр доступен только на платформе Яндекс Игр');
        }
    }

    // Вызываем инициализацию SDK
    initYandexSDK();

    function fetchSkinList() {
        fetch('https://raw.githubusercontent.com/etoniko/agarsu/refs/heads/main/skinlist.txt')
            .then(response => {
                if (!response.ok) {
                    throw new Error('Ошибка сети: ' + response.status);
                }
                return response.text();
            })
            .then(data => {
                skinList = {}; // Очищаем предыдущий список скинов
                data.split('\n').forEach(line => {
                    let [name, id] = line.split(':');
                    if (name && id) {
                        // Заменяем _ на пробелы в имени
                        name = name.trim().replace(/_/g, ' ').toLowerCase();
                        skinList[name] = id.trim();
                    }
                });
                console.log('Скин загружен:', skinList);
            })
            .catch(error => {
                console.error('Ошибка загрузки skinList.txt:', error);
            });
    }

    fetchSkinList();
    // Периодически проверяем изменения в skinList.txt
    //setInterval(fetchSkinList, 10000); // Проверяем каждые 60 секунд

    // Функция для загрузки данных о топ-1 игроке
    wHandle.chekstats = async function () {
        try {
            // Получаем текущий домен из CONNECTION_URL (или другого источника)
            const domain = CONNECTION_URL || window.location.hostname; // Используем текущий домен если CONNECTION_URL не задан

            // Формируем URL для запроса статистики
            const statsUrl = `https://${domain}/checkStats`;

            // Выполняем запрос
            const response = await fetch(statsUrl, { method: 'GET' });
            if (!response.ok) {
                throw new Error(`Ошибка запроса: ${response.status}`);
            }

            const stat = await response.json();

            // Выводим данные в консоль и выполняем обработку
            console.log(stat);
            loadTopPlayerData(stat);
            fetchStats(stat);
        } catch (error) {
            console.error('Ошибка загрузки данных о топ-1 игроке:', error);
        }
    };

    // Установка параметров подключения
    ONLY_CLIENT = false;
    let CONNECTION_URL = "itana.pw:6001";
    const hash = location.hash;
    if (hash === "#ffa") {
        CONNECTION_URL = "itana.pw:6001";
    } else if (hash === "#crazy") {
        CONNECTION_URL = "itana.pw:6002";
    }
    var
        // touchX, touchY,
        touchable = 'createTouch' in window || navigator.maxTouchPoints > 0,
        touches = [];

    var leftTouchID = -1,
        leftTouchPos = new Vector2(0, 0),
        leftTouchStartPos = new Vector2(0, 0),
        leftVector = new Vector2(0, 0);

    var useHttps = "https:" === wHandle.location.protocol;



    // Функция получения токена капчи 
    wHandle.captchaPassed = function () {
        const captchaContainer = document.getElementById('captcha-overlay');
        captchaContainer.style.display = 'none';
    }

    wHandle.onCaptchaSuccess = function (token) {
        showConnecting(token);
        captchaPassed();
        document.getElementById("button-text").disabled = false;
        document.getElementById("button-spec").disabled = false;
    };

    let captchaId = null;

    const renderCaptcha = () => {
        if (captchaId !== null) { // Сбрасываем капчу если она уже создана
            document.getElementById('captcha-overlay').style.display = '';
            turnstile.reset(captchaId);
            return;
        }

        const overlay = document.createElement("div");
        overlay.id = "captcha-overlay";

        const container = document.createElement("div");
        container.id = "captcha-container";

        overlay.appendChild(container);

        document.body.prepend(overlay);

        captchaId = turnstile.render(container, {
            sitekey: "0x4AAAAAAA0keHJ56_KNR0MU",
            callback: onCaptchaSuccess
        });

    };

    const showCaptcha = () => {
        // Перенаправляем на рендер если библиотека уже загружена
        if (window.turnstile) return renderCaptcha();

        // Загружаем библиотеку
        const node = document.createElement('script');
        node.setAttribute('src', 'https://challenges.cloudflare.com/turnstile/v0/api.js');
        node.setAttribute('async', 'async');
        node.setAttribute('defer', 'defer');
        node.onload = () => {
            renderCaptcha();
        };
        node.onerror = () => {
            alert("Не удалось загрузить библиотеку Captcha. Попробуйте обновить браузер");
        };

        document.head.appendChild(node);
    };

    // Обновляем setserver функцию для вызова showConnecting() вручную
    wHandle.setserver = function (arg) {
        if (arg !== CONNECTION_URL) {
            CONNECTION_URL = arg;
            // Update the hash based on the new server
            if (arg === "itana.pw:6002") {
                window.location.hash = "#crazy";
            } else if (arg === "itana.pw:6001") {
                window.location.hash = "#ffa";
            } else {
                console.warn("Unknown server URL:", arg);
                window.location.hash = ""; // Or some default hash
            }

            // Открываем ввод капчи на экран
            showCaptcha();

            // Attempt to reconnect with the new server.
            // if (captokenCloudflare) {
            //     showConnecting(captokenCloudflare);
            // } else {
            //     console.log("Captcha token is not available yet.");
            // }
        }
    };

    function gameLoop() {
        ma = true;
        document.getElementById("canvas").focus();
        var isTyping = false;
        var txt;
        mainCanvas = nCanvas = document.getElementById("canvas");
        ctx = mainCanvas.getContext("2d");

        mainCanvas.onmousemove = function (event) {
            const dpr = window.devicePixelRatio;
            rawMouseX = event.clientX * dpr;
            rawMouseY = event.clientY * dpr;
            mouseCoordinateChange()
        };

        const updateMouseAim = () => {
            let x = X < rightPos ? X : rightPos;
            let y = Y < bottomPos ? Y : bottomPos;
            x = -rightPos > x ? -rightPos : x;
            y = -bottomPos > y ? -bottomPos : y;

            // change cords
            posX = x;
            posY = y;
        };

        mainCanvas.addEventListener("mousedown", () => {
            // Owned player count 0 -> is spectate or dead
            if (!playerCells.length) { // Update spectate position
                updateMouseAim();
                sendUint8(1);
            }
        });


        if (touchable) {
            mainCanvas.addEventListener('touchstart', onTouchStart, false);
            mainCanvas.addEventListener('touchmove', onTouchMove, false);
            mainCanvas.addEventListener('touchend', onTouchEnd, false);
        }

        mainCanvas.onmouseup = function () {
        };
        if (/firefox/i.test(navigator.userAgent)) {
            document.addEventListener("DOMMouseScroll", handleWheel, false);
        } else {
            document.body.onmousewheel = handleWheel;
        }

        mainCanvas.onfocus = function () {
            isTyping = false;
        };

        document.getElementById("chat_textbox").onblur = function () {
            isTyping = false;
        };


        document.getElementById("chat_textbox").onfocus = function () {
            isTyping = true;
        };

        var spacePressed = false,
            qPressed = false,
            ePressed = false,
            rPressed = false,
            tPressed = false,
            pPressed = false,
            wPressed = false,
            wInterval; // Variable to hold the interval for 'W' key press

        wHandle.onkeydown = function (event) {
            switch (event.keyCode) {
                case 13: // enter
                    if (isTyping || hideChat) {
                        isTyping = false;
                        document.getElementById("chat_textbox").blur();
                        chattxt = document.getElementById("chat_textbox").value;
                        if (chattxt.length > 0) sendChat(chattxt);
                        document.getElementById("chat_textbox").value = "";
                    } else {
                        document.getElementById("chat_textbox").focus();
                        isTyping = true;
                    }
                    break;
                case 32: // space
                    if (!spacePressed && !isTyping) {
                        sendMouseMove();
                        sendUint8(17);
                        spacePressed = true;
                    }
                    break;
                case 87: // W
                    if (!wPressed && !isTyping) {
                        sendMouseMove();
                        sendUint8(21);
                        wPressed = true;

                        // Start the interval when 'W' is pressed
                        wInterval = setInterval(function () {
                            sendMouseMove();
                            sendUint8(21);
                        }, 100);
                    }
                    break;
                case 81: // Q
                    if (!qPressed && !isTyping) {
                        sendUint8(18);
                        qPressed = true;
                    }
                    break;
                case 69: // E
                    if (!ePressed && !isTyping) {
                        sendMouseMove();
                        sendUint8(22);
                        ePressed = true; // Added missing ePressed flag
                    }
                    break;
                case 82: // R
                    if (!rPressed && !isTyping) {
                        sendMouseMove();
                        sendUint8(23);
                        rPressed = true; // Added missing rPressed flag
                    }
                    break;
                case 84: // T
                    if (!tPressed && !isTyping) {
                        sendMouseMove();
                        sendUint8(24);
                        tPressed = true;
                    }
                    break;
                case 80: // P
                    if (!pPressed && !isTyping) {
                        sendMouseMove();
                        sendUint8(25);
                        pPressed = true;
                    }
                    break;
            }
        };

        wHandle.onkeyup = function (event) {
            switch (event.keyCode) {
                case 32: // space
                    spacePressed = false;
                    break;
                case 87: // W
                    wPressed = false;

                    // Clear the interval when 'W' is released
                    clearInterval(wInterval);
                    break;
                case 81: // Q
                    if (qPressed) {
                        sendUint8(19);
                        qPressed = false;
                    }
                    break;
                case 69: // E
                    ePressed = false;
                    break;
                case 82: // R
                    rPressed = false;
                    break;
                case 84: // T
                    tPressed = false;
                    break;
                case 80: // P
                    pPressed = false;
                    break;
            }
        };

        wHandle.onblur = function () {
            sendUint8(19);
            clearInterval(wInterval); // Ensure the interval is cleared on blur
            wPressed = spacePressed = qPressed = ePressed = rPressed = tPressed = pPressed = false;
        };


        $(document).ready(function () {
            // Handle keydown event
            $(document).keydown(function (event) {
                if (event.keyCode === 27) { // Check if the Escape key is pressed
                    const overlay = $('#overlays');
                    if (overlay.is(':visible')) {
                        overlay.hide(); // Hide the overlay if currently visible
                    } else {
                        overlay.show(); // Show the overlay if currently hidden
                    }
                }
            });
        });


        wHandle.onresize = canvasResize;
        canvasResize();
        if (wHandle.requestAnimationFrame) {
            wHandle.requestAnimationFrame(redrawGameScene);
        } else {
            setInterval(drawGameScene, 1E3 / 60);
        }
        setInterval(sendMouseMove, 50);

        wjQuery("#overlays").show();

        showCaptcha();
        // wsConnect("");
    }

const dpr = window.devicePixelRatio;

const joystickRadius = 360; // Максимальное расстояние точки от центра джойстика
const cursorSize = 20; // Размер квадрата курсора

let splitPressed = false;
let ejectPressed = false;

let pinchZoomStartDistance = 0;
let isPinching = false;

function onTouchStart(e) {
    for (var i = 0; i < e.changedTouches.length; i++) {
        var touch = e.changedTouches[i];

        var size = ~~(canvasWidth / 7);

        // Проверяем, касается ли нажатие кнопки "split"
        if (
            touch.clientX * dpr > canvasWidth - size &&
            touch.clientY * dpr > canvasHeight - size
        ) {
            sendMouseMove();
            sendUint8(17); // split
            splitPressed = true;
            continue;
        }

        // Проверяем, касается ли нажатие кнопки "eject"
        if (
            touch.clientX * dpr > canvasWidth - size &&
            touch.clientY * dpr > canvasHeight - 2 * size - 10 &&
            touch.clientY * dpr < canvasHeight - size - 10
        ) {
            sendMouseMove();
            sendUint8(21); // eject
            ejectPressed = true;
            continue;
        }

        // Если это не кнопка, обрабатываем как джойстик
        if (leftTouchID < 0) {
            leftTouchID = touch.identifier;
            leftTouchStartPos.reset(touch.clientX * dpr, touch.clientY * dpr);
            leftTouchPos.copyFrom(leftTouchStartPos);
            leftVector.reset(0, 0);
        }
    }
    touches = e.touches;
}

function onTouchMove(e) {
    e.preventDefault();

    // === Пинч-зум (двумя пальцами) ===
    if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const currentDistance = Math.sqrt(dx * dx + dy * dy);

        if (!isPinching) {
            pinchZoomStartDistance = currentDistance;
            isPinching = true;
        } else {
            const delta = currentDistance - pinchZoomStartDistance;
            const zoomFactor = 1 + delta / 300; // Настройка чувствительности
            zoom *= zoomFactor;

            // Ограничения
            if (zoom < 0.3) zoom = 0.3;
            if (zoom > 4 / viewZoom) zoom = 4 / viewZoom;

            pinchZoomStartDistance = currentDistance;
        }

        return; // Не продолжаем обработку джойстика, если пинч
    }

    // === Обычное касание (джойстик) ===
    for (var i = 0; i < e.changedTouches.length; i++) {
        var touch = e.changedTouches[i];

        if (leftTouchID === touch.identifier) {
            leftTouchPos.reset(touch.clientX * dpr, touch.clientY * dpr);
            leftVector.copyFrom(leftTouchPos);
            leftVector.minusEq(leftTouchStartPos);

            const distance = Math.sqrt(leftVector.x ** 2 + leftVector.y ** 2);
            if (distance > joystickRadius) {
                const scale = joystickRadius / distance;
                leftVector.x *= scale;
                leftVector.y *= scale;
                leftTouchPos.x = leftTouchStartPos.x + leftVector.x;
                leftTouchPos.y = leftTouchStartPos.y + leftVector.y;
            }

            rawMouseX = leftVector.x * 3 + canvasWidth / 2;
            rawMouseY = leftVector.y * 3 + canvasHeight / 2;
            mouseCoordinateChange();
            sendMouseMove();
        }
    }
    touches = e.touches;
}

function onTouchEnd(e) {
    // Сброс пинча, если пальцев меньше двух
    if (e.touches.length < 2) {
        isPinching = false;
    }

    for (var i = 0; i < e.changedTouches.length; i++) {
        var touch = e.changedTouches[i];

        if (leftTouchID === touch.identifier) {
            leftTouchID = -1;
            leftVector.reset(0, 0);
        }
    }
    touches = e.touches;
}

function handleWheel(event) {
    const overlay = $('#overlays');
    const chatContainer = $('#chat-container');

    if (overlay.is(':visible') || isMouseOverElement(chatContainer)) {
        return;
    }

    zoom *= Math.pow(.9, event.wheelDelta / -120 || event.detail || 0);
    if (zoom < 0) zoom = 1;
    if (zoom > 4 / viewZoom) zoom = 4 / viewZoom;
    if (zoom < 0.3) zoom = 0.3;
}

function isMouseOverElement(element) {
    const mouseX = event.clientX;
    const mouseY = event.clientY;
    const offset = element.offset();

    return mouseX >= offset.left && mouseX <= offset.left + element.width() &&
           mouseY >= offset.top && mouseY <= offset.top + element.height();
}


    function buildQTree() {
        if (.4 > viewZoom) qTree = null;
        else {
            var a = Number.POSITIVE_INFINITY,
                b = Number.POSITIVE_INFINITY,
                c = Number.NEGATIVE_INFINITY,
                d = Number.NEGATIVE_INFINITY,
                e = 0;
            for (var i = 0; i < nodelist.length; i++) {
                var node = nodelist[i];
                if (node.shouldRender() && !node.prepareData && 20 < node.size * viewZoom) {
                    e = Math.max(node.size, e);
                    a = Math.min(node.x, a);
                    b = Math.min(node.y, b);
                    c = Math.max(node.x, c);
                    d = Math.max(node.y, d);
                }
            }
            qTree = Quad.init({
                minX: a - (e + 100),
                minY: b - (e + 100),
                maxX: c + (e + 100),
                maxY: d + (e + 100),
                maxChildren: 2,
                maxDepth: 4
            });
            for (i = 0; i < nodelist.length; i++) {
                node = nodelist[i];
                if (node.shouldRender() && !(20 >= node.size * viewZoom)) {
                    for (a = 0; a < node.points.length; ++a) {
                        b = node.points[a].x;
                        c = node.points[a].y;
                        b < nodeX - canvasWidth / 2 / viewZoom || c < nodeY - canvasHeight / 2 / viewZoom || b > nodeX + canvasWidth / 2 / viewZoom || c > nodeY + canvasHeight / 2 / viewZoom || qTree.insert(node.points[a]);
                    }
                }
            }
        }
    }

    function mouseCoordinateChange() {
        X = (rawMouseX - canvasWidth / 2) / viewZoom + nodeX;
        Y = (rawMouseY - canvasHeight / 2) / viewZoom + nodeY
    }

    function hideOverlays() {
        // hasOverlay = false;
        wjQuery("#overlays").hide();
    }

    function showOverlays(arg) {
        // hasOverlay = true;
        userNickName = null;
        wjQuery("#overlays").fadeIn(arg ? 200 : 3E3);
    }

    let currentWebSocketUrl = null;

    function showConnecting(token) {
        chekstats();
        // Формируем полный URL для WebSocket
        const wsUrl = (useHttps ? "wss://" : "ws://") + CONNECTION_URL;

        // Проверяем, что соединение не установлено и что текущий URL не совпадает с уже подключенным
        if (ws && ws.readyState === WebSocket.OPEN && currentWebSocketUrl === wsUrl) {
            console.log("Соединение уже активно для этого URL, пропускаем повторное подключение.");
            return;
        }

        if (ma) {
            wjQuery("#connecting").show();
            currentWebSocketUrl = wsUrl; // Запоминаем текущий URL
            wsConnect(wsUrl, token);
        }
    };


    function wsConnect(undefined, token) {
        if (ws) {
            ws.onopen = null;
            ws.onmessage = null;
            ws.onclose = null;
            try {
                ws.close()
            } catch (b) {
            }
            ws = null
        }
        var c = CONNECTION_URL;
        wsUrl = (useHttps ? "wss://" : "ws://") + c;

        // var c = "ws://localhost:3000/";
        // wsUrl = c;

        nodesOnScreen = [];
        playerCells = [];
        nodes = {};
        nodelist = [];
        Cells = [];
        leaderBoard = [];
        mainCanvas = teamScores = null;
        // userScore = 0;
        log.info("Connecting to " + wsUrl + "..");

        // Передаем токен при подключении xxxevexxx
        const params = `?token=${encodeURIComponent(token)}`;
        ws = new WebSocket(wsUrl + params, "eSejeKSVdysQvZs0ES1H");
        ws.binaryType = "arraybuffer";
        ws.onopen = onWsOpen;
        ws.onmessage = onWsMessage;
        ws.onclose = onWsClose;
    }

    function prepareData(a) {
        return new DataView(new ArrayBuffer(a))
    }

    function wsSend(a) {
        ws.send(a.buffer)
    }

    function httpGet(theUrl) {
        var xmlHttp = new XMLHttpRequest();
        xmlHttp.open("GET", theUrl, false); // false for synchronous request
        xmlHttp.send(null);
        return xmlHttp.responseText;
    }

    function onWsOpen() {
        var msg;
        // delay = 500;
        wjQuery("#connecting").hide();

        sendAccountToken();

        msg = prepareData(5);
        msg.setUint8(0, 254);
        msg.setUint32(1, 5, true); // Protocol 5
        wsSend(msg);

        msg = prepareData(5);
        msg.setUint8(0, 255);
        msg.setUint32(1, 0, true);
        wsSend(msg);

        sendNickName();
        log.info("Connection successful!");
    }

        function onWsClose(evt) {
            console.log(evt);
            let serverCloseDiv = document.getElementById("serverclose-overlay");

            if (serverCloseDiv) {
                serverCloseDiv.style.display = "block";
                startCountdown();
            } else {
                console.warn("Элемент с id 'serverclose-overlay' не найден.");
            }
        }

        function startCountdown() {
            let countdownElement = document.getElementById("countdown");
            let seconds = 10;

            let countdownInterval = setInterval(function() {
                seconds--;
                countdownElement.textContent = "Перезагрузка через: " + seconds;

                if (seconds <= 0) {
                    clearInterval(countdownInterval);
                    location.reload(); // Перезагружаем страницу
                }
            }, 1000); // Обновляем каждую секунду
        }



    function onWsMessage(msg) {
        handleWsMessage(new DataView(msg.data));
    }

    class BinaryReader {
        constructor(view) {
            this.view = view;
            this.byteLength = view.byteLength;
        }
        get canRead() {
            return this.offset < this.byteLength;
        }
        uint8() {
            return this.view.getUint8(this.offset++);
        }
        int8() {
            return this.view.getInt8(this.offset++);
        }
        uint16() {
            return this.view.getUint16((this.offset += 2) - 2, true);
        }
        int16() {
            return this.view.getInt16((this.offset += 2) - 2, true);
        }
        uint32() {
            return this.view.getUint32((this.offset += 4) - 4, true);
        }
        int32() {
            return this.view.getInt32((this.offset += 4) - 4, true);
        }
        utf16() {
            let str = "";
            let char;
            while (this.canRead && (char = this.uint16())) str += String.fromCharCode(char);
            return str;
        }
    };
    BinaryReader.prototype.offset = 0;

    function handleWsMessage(msg) {
        let offset = 0;
        let setCustomLB = false;

        function getString() {
            let text = '';
            let char;
            while ((char = msg.getUint16(offset, true)) !== 0) {
                offset += 2;
                text += String.fromCharCode(char);
            }
            offset += 2;
            return text;
        }

        //if (msg.getUint8(offset) === 240) offset += 5;

        const messageType = msg.getUint8(offset++);
        switch (messageType) {
            case 16:
                // Update nodes
                const reader = new BinaryReader(msg);
                reader.offset++; // skip messageType
                updateNodes(reader);
                break;
            case 17:
                // Update position
                // posX = msg.getFloat32(offset, true);
                // offset += 4;
                // posY = msg.getFloat32(offset, true);

                posSize = 0.15;

                // offset += 4;
                // posSize = msg.getFloat32(offset, true);
                // offset += 4;
                break;
            case 20:
                // Clear nodes
                playerCells = [];
                nodesOnScreen = [];
                break;
            case 21:
                // Draw line
                lineX = msg.getInt16(offset, true);
                offset += 2;
                lineY = msg.getInt16(offset, true);
                offset += 2;
                if (!drawLine) {
                    drawLine = true;
                    drawLineX = lineX;
                    drawLineY = lineY;
                }
                break;
            case 32:
                // Add node
                nodesOnScreen.push(msg.getUint32(offset, true));
                offset += 4;
                break;
            case 48:
                // Update leaderboard (custom text)
                setCustomLB = true;
                noRanking = true;
                break;
            case 49:
                // Update leaderboard (ffa)
                if (!setCustomLB) {
                    noRanking = false;
                }
                const LBplayerNum = msg.getUint32(offset, true);
                offset += 4;
                leaderBoard = [];
                for (let i = 0; i < LBplayerNum; ++i) {
                    const nodeId = msg.getUint32(offset, true);
                    offset += 4;

                    const playerName = getString();

                    const playerXp = msg.getUint32(offset, true);
                    offset += 4;
                    const level = playerXp ? getLevel(playerXp) : -1;

                    leaderBoard.push({
                        id: nodeId,
                        name: playerName,
                        level
                    });
                }
                drawLeaderBoard();
                break;
            case 50:
                // Update leaderboard (teams)
                teamScores = [];
                const LBteamNum = msg.getUint32(offset, true);
                offset += 4;
                for (let i = 0; i < LBteamNum; ++i) {
                    teamScores.push(msg.getFloat32(offset, true));
                    offset += 4;
                }
                drawLeaderBoard();
                break;
            case 64:
                // Set border
                leftPos = msg.getFloat64(offset, true);
                offset += 8;
                topPos = msg.getFloat64(offset, true);
                offset += 8;
                rightPos = msg.getFloat64(offset, true);
                offset += 8;
                bottomPos = msg.getFloat64(offset, true);
                offset += 8;
                foodMinSize = (msg.getUint16(offset, true) * 100) ** .5;
                offset += 2;
                foodMaxSize = (msg.getUint16(offset, true) * 100) ** .5;
                offset += 2;

                mapWidth = (rightPos + leftPos) / 2;
                mapHeight = (bottomPos + topPos) / 2;

                posX = (rightPos + leftPos) / 2;
                posY = (bottomPos + topPos) / 2;
                posSize = 1;

                if (playerCells.length === 0) {
                    nodeX = posX;
                    nodeY = posY;
                    viewZoom = posSize;
                }
                break;
            case 99:
                // Add chat message
                addChat(msg, offset);
                break;
            case 114:
                // Update eXP
                const xp = msg.getUint32(offset, true);
                onUpdateXp(xp);
                break;
        }
    }


    function addChat(view, offset) {
        function getString() {
            var text = '',
                char;
            while ((char = view.getUint16(offset, true)) != 0) {
                offset += 2;
                text += String.fromCharCode(char);
            }
            offset += 2;
            return text;
        }

        var flags = view.getUint8(offset++);

        if (flags & 0x80) {
            // SERVER Message
        }

        if (flags & 0x40) {
            // ADMIN Message
        }

        if (flags & 0x20) {
            // MOD Message
        }

        var r = view.getUint8(offset++),
            g = view.getUint8(offset++),
            b = view.getUint8(offset++),
            color = (r << 16 | g << 8 | b).toString(16);
        while (color.length < 6) {
            color = '0' + color;
        }
        color = '#' + color;
        chatBoard.push({
            "name": getString(),
            "color": color,
            "message": getString(),
            "time": formatTime(new Date()) // Форматируем текущее время
        });
        drawChatBoard();
applyNicknameLimit();
    }

    function formatTime(date) {
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        return `${hours}:${minutes}`; // Возвращаем строку в формате HH:MM
    }

    // Список администраторов
    const admins = ["нико"]; // Укажите ники администраторов


let badWordsSet; // Используем Set вместо массива

fetch('https://cdn.jsdelivr.net/gh/etoniko/agarsu/word.txt')
    .then(response => response.text())
    .then(text => {
        const words = text.split('\n').map(word => word.trim().toLowerCase());
        badWordsSet = new Set(words); // Создаем Set из массива
    })
    .catch(error => console.error('Ошибка загрузки списка матерных слов:', error));


function censorMessage(message) {
    if (!badWordsSet) {
        console.warn("Список матерных слов не загружен. Антимат не работает.");
        return message;
    }

    const words = message.split(' ').filter(word => word !== "");
    let censoredMessage = "";  // Собираем результат в строку
    for (let i = 0; i < words.length; i++) {
        const word = words[i];
        const lowerCaseWord = word.toLowerCase();

        if (badWordsSet.has(lowerCaseWord)) {
            censoredMessage += word[0] + "***";
        } else {
            censoredMessage += word;
        }

        if (i < words.length - 1) {
            censoredMessage += " "; // Добавляем пробел, если это не последнее слово
        }
    }
    return censoredMessage;
}



 function drawChatBoard() {
        if (hideChat) {
            return;
        }

        // Очищаем существующий контент чата
        const chatDiv = document.getElementById('chat-container');
        chatDiv.innerHTML = '';

        // Рисуем сообщения, начиная с самых новых
        const messageCount = chatBoard.length;
        const startIndex = Math.max(messageCount - 16, 0);

        for (let i = 0; i < messageCount - startIndex; i++) {
            const messageIndex = startIndex + i;
            const message = chatBoard[messageIndex];

            // Создаем новый div для сообщения с классом scoreshint
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('scoreshint');

            // Проверяем, является ли отправитель администратором
            if (admins.includes(message.name.toLowerCase())) {
                messageDiv.classList.add('admin'); // Применяем класс админа
            }

            // Создаем текстовые элементы для имени, сообщения и времени
            const nameSpan = document.createElement('span');
            nameSpan.classList.add('chat-name');
            nameSpan.style.color = admins.includes(message.name) ? 'gold' : message.color; // Устанавливаем цвет имени
            nameSpan.textContent = message.name + ': '; // Добавляем двоеточие

            const messageSpan = document.createElement('span');
            messageSpan.classList.add('chat-text');
            //  Применяем антимат к сообщению
            messageSpan.textContent = censorMessage(message.message);

            const timeSpan = document.createElement('span'); // Создаем элемент для времени
            timeSpan.classList.add('chat-time');
            timeSpan.textContent = message.time; // Добавляем время к сообщению

            // Добавляем текстовые элементы в div сообщения
            messageDiv.appendChild(nameSpan);
            messageDiv.appendChild(messageSpan);
            messageDiv.appendChild(timeSpan); // Добавляем время в сообщение

            // Создаем span для скина
            const skinSpan = document.createElement('span');
            skinSpan.classList.add('chat-skin');

            // Получаем id скина из skinList
            const skinId = skinList[message.name.toLowerCase()]; // Получаем id скина по нику

            // Проверяем, существует ли id скина
            if (skinId) {
                const skinImagePath = `https://i.imgur.com/${skinId}.png`; // Формируем путь к изображению скина
                const skinImg = new Image();
                skinImg.src = skinImagePath;

                skinImg.onload = function () {
                    skinSpan.style.backgroundImage = `url(${skinImagePath})`;
                };

                skinImg.onerror = function () {
                    skinSpan.style.backgroundImage = 'url(https://i.imgur.com/PPFtwqH.png)'; // Устанавливаем запасное изображение
                };
            } else {
                // Устанавливаем запасное изображение, если id скина не найден
                skinSpan.style.backgroundImage = 'url(https://i.imgur.com/PPFtwqH.png)';
            }

            // Добавляем скин в контейнер чата
            chatDiv.appendChild(skinSpan); // Скин добавляется отдельно

            // Добавляем div сообщения в контейнер чата
            chatDiv.appendChild(messageDiv);
        }

        // Устанавливаем прокрутку в самый низ
        chatDiv.scrollTop = chatDiv.scrollHeight;
    }

function applyNicknameLimit() {
    const chatDivs = document.querySelectorAll('.scoreshint');

    chatDivs.forEach(chatDiv => {
        const chatTextSpan = chatDiv.querySelector('.chat-text');

        if (chatTextSpan && chatTextSpan.textContent.includes(' вошел в игру!')) {
            // Находим никнейм игрока (предполагаем, что ник перед " вошел в игру!")
            const messageText = chatTextSpan.textContent;
            const nickname = messageText.substring(0, messageText.indexOf('вошел в игру!'));

            // Создаем новый span для ника с ограничением
            const nicknameSpan = document.createElement('span');
            nicknameSpan.style.overflow = 'hidden';
            nicknameSpan.style.maxWidth = '95px';  // Максимальная ширина
            nicknameSpan.style.marginRight = '5px'; // или любое другое значение
            nicknameSpan.style.whiteSpace = 'nowrap';
            nicknameSpan.style.textOverflow = 'ellipsis';
            nicknameSpan.style.display = 'inline-block'; // Важно!
            nicknameSpan.style.flexShrink = '0';  // Не сжимать!
            nicknameSpan.textContent = nickname;

            // Заменяем исходный текст в chatTextSpan, оставив только " вошел в игру!"
            chatTextSpan.textContent = 'вошел в игру!';

            // Добавляем ник с ограничением в начало chatTextSpan
            chatTextSpan.prepend(nicknameSpan);

            // Делаем chatTextSpan flex-контейнером
            chatTextSpan.style.display = 'flex';
            chatTextSpan.style.alignItems = 'center'; // Выравнивание по вертикали (по желанию)
        }
    });
}


    const normalizeFractlPart = n => (n % (Math.PI * 2)) / (Math.PI * 2);

    async function showSDK() {
        // Проверяем, что SDK инициализирован и игра запущена на платформе Яндекс Игр
        if (window.ysdk && isYandexGamesPlatform()) {
            try {
                // Останавливаем геймплей и ждем завершения
                await window.ysdk.features.GameplayAPI?.stop();
                console.log("Геймплей остановлен");
            } catch (err) {
                console.error("Ошибка при работе с SDK Яндекс Игр:", err);
            }
        } else {
            console.warn("SDK Яндекс Игр не инициализирован или игра не на платформе Яндекс Игр");
        }
    }

    function updateNodes(reader) {
        timestamp = Date.now();
        ua = false;
        for (let killerId; killerId = reader.uint32();) {
            var killer = nodes[killerId],
                killedNode = nodes[reader.uint32()];
            if (killer && killedNode) {
                killedNode.destroy();
                killedNode.ox = killedNode.x;
                killedNode.oy = killedNode.y;
                killedNode.oSize = killedNode.size;
                killedNode.nx = killer.x;
                killedNode.ny = killer.y;
                killedNode.nSize = killedNode.size;
                killedNode.updateTime = timestamp;
            }
        }

        for (let nodeid; nodeid = reader.uint32();) {
            const type = reader.uint8();

            let posX = 0;
            let posY = 0;
            let size = 0;

            if (type === 1) {
                posX = leftPos + (rightPos * 2) * normalizeFractlPart(nodeid);
                posY = topPos + (bottomPos * 2) * normalizeFractlPart(nodeid * nodeid);
                size = foodMinSize + nodeid % ((foodMaxSize - foodMinSize) + 1);
            }
            else {
                posX = reader.int32();
                posY = reader.int32();
                size = reader.uint16();
            }

            for (var r = reader.uint8(), g = reader.uint8(), b = reader.uint8(),
                color = (r << 16 | g << 8 | b).toString(16); 6 > color.length;) color = "0" + color;
            var colorstr = "#" + color,
                flags = reader.uint8(),
                flagVirus = !!(flags & 0x01),
                flagEjected = !!(flags & 0x20),
                flagAgitated = !!(flags & 0x10),
                _skin = "";

            const name = reader.utf16();

            let node = nodes[nodeid];
            if (node) {
                node = nodes[nodeid];
                node.updatePos();
                node.ox = node.x;
                node.oy = node.y;
                node.oSize = node.size;
                node.color = colorstr;
            } else {
                node = new Cell(nodeid, posX, posY, size, colorstr, name, _skin);
                nodelist.push(node);
                nodes[nodeid] = node;
                node.ka = posX;
                node.la = posY;
            }
            node.isVirus = flagVirus;
            node.isEjected = flagEjected;
            node.isAgitated = flagAgitated;
            node.nx = posX;
            node.ny = posY;
            node.setSize(size);
            node.updateTime = timestamp;
            node.flag = flags;
            name && node.setName(name);
            if (-1 != nodesOnScreen.indexOf(nodeid) && -1 == playerCells.indexOf(node)) {
                document.getElementById("overlays").style.display = "none";
                playerCells.push(node);
                if (1 == playerCells.length) {
                    nodeX = node.x;
                    nodeY = node.y;
                }
            }
        }

        while (reader.canRead) {
            const node = nodes[reader.uint32()];
            null != node && node.destroy();
        }

        if (ua && playerCells.length === 0) {
            showGameOverStats(); // Вызов функции статистики
        }
    }
function showGameOverStats() {
    document.getElementById("staticks").style.display = "block";
}
    function sendMouseMove() {
        var msg;
        if (wsIsOpen()) {
            msg = rawMouseX - canvasWidth / 2;
            var b = rawMouseY - canvasHeight / 2;
            if (64 <= msg * msg + b * b && !(.01 > Math.abs(oldX - X) && .01 > Math.abs(oldY - Y))) {
                oldX = X;
                oldY = Y;
                msg = prepareData(21);
                msg.setUint8(0, 16);
                msg.setFloat64(1, X, true);
                msg.setFloat64(9, Y, true);
                msg.setUint32(17, 0, true);
                wsSend(msg);
            }
        }
    }

    const sendAccountToken = () => {
        const token = localStorage.accountToken;
        if (wsIsOpen() && token) {
            const msg = prepareData(1 + 2 * token.length);
            msg.setUint8(0, 114);
            for (var i = 0; i < token.length; ++i) msg.setUint16(1 + 2 * i, token.charCodeAt(i), true);
            wsSend(msg);
        }
    };

    function sendNickName() {
        if (wsIsOpen() && null != userNickName) {
            var msg = prepareData(1 + 2 * userNickName.length);
            msg.setUint8(0, 0);
            for (var i = 0; i < userNickName.length; ++i) msg.setUint16(1 + 2 * i, userNickName.charCodeAt(i), true);
            wsSend(msg)
        }
    }


    function sendChat(str) {
        if (wsIsOpen() && (str.length < 200) && (str.length > 0) && !hideChat) {
            var msg = prepareData(2 + 2 * str.length);
            var offset = 0;
            msg.setUint8(offset++, 99);
            msg.setUint8(offset++, 0); // flags (0 for now)
            for (var i = 0; i < str.length; ++i) {
                msg.setUint16(offset, str.charCodeAt(i), true);
                offset += 2;
            }

            wsSend(msg);
        }
    }

    function wsIsOpen() {
        return null != ws && ws.readyState == ws.OPEN
    }

    function sendUint8(a) {
        if (wsIsOpen()) {
            var msg = prepareData(1);
            msg.setUint8(0, a);
            wsSend(msg)
        }
    }


    function redrawGameScene() {
        drawGameScene();
        wHandle.requestAnimationFrame(redrawGameScene)
    }

    function canvasResize() {
        window.scrollTo(0, 0);

        // Используйте devicePixelRatio для корректного отображения на разных экранах
        const dpr = window.devicePixelRatio;

        // Получите размеры окна в пикселях
        canvasWidth = wHandle.innerWidth * dpr;
        canvasHeight = wHandle.innerHeight * dpr;

        // Установите размеры холста в пикселях
        nCanvas.width = canvasWidth;
        nCanvas.height = canvasHeight;

        // Масштабируйте контекст холста, чтобы изображение не размывалось
        nCanvas.style.width = `${wHandle.innerWidth}px`; // Установка стиля для правильного отображения
        nCanvas.style.height = `${wHandle.innerHeight}px`;

        // Обновите отрисовку
        drawGameScene();
    }

    function viewRange() {
        var ratio;
        ratio = Math.max(canvasHeight / 1080, canvasWidth / 1920);
        return ratio * zoom;
    }


    function calcViewZoom() {
        if (0 != playerCells.length) {
            for (var newViewZoom = 0, i = 0; i < playerCells.length; i++) newViewZoom += playerCells[i].size;
            newViewZoom = Math.pow(Math.min(64 / newViewZoom, 1), .4) * viewRange();
            viewZoom = (9 * viewZoom + newViewZoom) / 10;
        }
    }




    let lastDisplayedScore = 0;
    let lastDisplayedMaxScore = 0;
    let lastDisplayedCellCount = 0;
    let maxScore = 0;

    function drawGameScene() {

        var a, oldtime = Date.now();
        ++cb;
        timestamp = oldtime;

        if (playerCells.length > 0) {
            calcViewZoom();
            var c = a = 0;
            for (var d = 0; d < playerCells.length; d++) {
                playerCells[d].updatePos();
                a += playerCells[d].x / playerCells.length;
                c += playerCells[d].y / playerCells.length;
            }
            posX = a;
            posY = c;
            posSize = viewZoom;
            nodeX = (nodeX + a) / 2;
            nodeY = (nodeY + c) / 2;
        } else {
            nodeX = (29 * nodeX + posX) / 30;
            nodeY = (29 * nodeY + posY) / 30;
            viewZoom = (9 * viewZoom + posSize * viewRange()) / 10;
        }

        buildQTree();
        mouseCoordinateChange();
            drawGrid();
            drawCenterBackground();

        nodelist.sort((a, b) => a.size === b.size ? a.id - b.id : a.size - b.size);

        ctx.save();
        ctx.translate(canvasWidth / 2, canvasHeight / 2);
        ctx.scale(viewZoom, viewZoom);
        ctx.translate(-nodeX, -nodeY);
        for (d = 0; d < Cells.length; d++) Cells[d].drawOneCell(ctx);
        for (d = 0; d < nodelist.length; d++) nodelist[d].drawOneCell(ctx);

        if (drawLine) {
            drawLineX = (3 * drawLineX + lineX) / 4;
            drawLineY = (3 * drawLineY + lineY) / 4;
            ctx.save();
            ctx.strokeStyle = "#FFAAAA";
            ctx.lineWidth = 10;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.globalAlpha = .5;
            ctx.beginPath();
            for (d = 0; d < playerCells.length; d++) {
                ctx.moveTo(playerCells[d].x, playerCells[d].y);
                ctx.lineTo(drawLineX, drawLineY);
            }
            ctx.stroke();
            ctx.restore();
        }

        ctx.restore();
        lbCanvas && lbCanvas.width && ctx.drawImage(lbCanvas, canvasWidth - lbCanvas.width - 10, 10); // draw Leader Board
        if (chatCanvas != null) ctx.drawImage(chatCanvas, 0, canvasHeight - chatCanvas.height - 50); // draw Leader Board

        // Calculate the current score
        const currentScore = Math.floor(calcUserScore() / 100);
        maxScore = Math.max(maxScore, currentScore);
        const cellCount = playerCells.length;

        // Update the score-max div only if the max score has changed
        if (maxScore !== lastDisplayedMaxScore) {
            document.getElementById('score-max').innerText = 'Максимум: ' + maxScore;
            lastDisplayedMaxScore = maxScore; // Update last displayed max score
        }

        // Update the score-new div only if the current score has changed
        if (currentScore !== lastDisplayedScore) {
            document.getElementById('score-new').innerText = 'Сейчас: ' + currentScore;
            lastDisplayedScore = currentScore; // Update last displayed score
        }

        // Update the cell-length div only if the cell count has changed
        if (cellCount !== lastDisplayedCellCount) {
            document.getElementById('cell-length').innerText = cellCount;
            lastDisplayedCellCount = cellCount; // Update last displayed cell count
        }

        drawSplitIcon(ctx);
        drawTouch(ctx);

        var deltatime = Date.now() - oldtime;
        deltatime > 1E3 / 60 ? z -= .01 : deltatime < 1E3 / 65 && (z += .01);
        .4 > z && (z = .4);
        1 < z && (z = 1);
    }


    function drawTouch(ctx) {
        ctx.save();
        if (touchable) {
            for (var i = 0; i < touches.length; i++) {
                var touch = touches[i];
                if (touch.identifier == leftTouchID) {
                    // Джойстик
                    ctx.beginPath();
                    ctx.strokeStyle = "#0096ff";
                    ctx.lineWidth = 6;
                    ctx.arc(leftTouchStartPos.x, leftTouchStartPos.y, 40, 0, Math.PI * 2, true);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.strokeStyle = "#0096ff";
                    ctx.lineWidth = 2;
                    ctx.arc(leftTouchStartPos.x, leftTouchStartPos.y, 140, 0, Math.PI * 2, true);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.strokeStyle = "#0096ff";
                    ctx.arc(leftTouchPos.x, leftTouchPos.y, 40, 0, Math.PI * 2, true);
                    ctx.stroke();

                    // Курсор
                    ctx.fillStyle = "#0096ff";
                    ctx.fillRect(
                        rawMouseX - cursorSize / 2,
                        rawMouseY - cursorSize / 2,
                        cursorSize,
                        cursorSize
                    );
                }
            }
        }
        ctx.restore();
    }


// Функция для получения значения куки по имени
function getCookie(name) {
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) return parts.pop().split(';').shift();
}

// Функция для установки куки
function setCookie(name, value, days) {
  let expires = "";
  if (days) {
    const date = new Date();
    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
    expires = "; expires=" + date.toUTCString();
  }
  document.cookie = name + "=" + (value || "") + expires + "; path=/";
}

// Функция для определения темы ОС по умолчанию
function getDefaultTheme() {
  if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    return 'black'; // Или 'gradient'
  } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
    return 'white'; // Или 'gradient'
  } else {
    return 'gradient'; // Если невозможно определить
  }
}

// Функция отрисовки сетки (БЕЗ аргументов, читает тему из куки или ОС)
function drawGrid() {
  const savedTheme = getCookie('grid_theme');
  let themeToDraw = savedTheme || getDefaultTheme(); // Используем тему из куки или тему ОС

  switch (themeToDraw) {
    case 'gradient':
      drawGradientGrid();
      break;
    case 'white':
      drawWhiteGrid();
      break;
    case 'black':
      drawBlackGrid();
      break;
    default:
      drawGradientGrid(); // Обработка неизвестной темы
  }
}

document.addEventListener('DOMContentLoaded', function() {
  const selectElement = document.getElementById('theme-select');

  // Добавляем обработчик события изменения выбранной темы
  selectElement.addEventListener('change', function() {
    const selectedTheme = this.value;
    setCookie('grid_theme', selectedTheme, 30); // Сохраняем в куки
    drawGrid(); // Отрисовываем сетку
  });

  // Проверяем, есть ли тема в куках
  let savedTheme = getCookie('grid_theme');
  if (!savedTheme) {
      // Если нет темы в куках, получаем тему ОС по умолчанию
      savedTheme = getDefaultTheme();
      setCookie('grid_theme', savedTheme, 30); // Сохраняем тему ОС в куки
  }

  // Устанавливаем выбранную тему в селекторе
  selectElement.value = savedTheme;
});



    // Новая версия с градиентом
    function drawGradientGrid() {
        // Позиции центра карты
        const mapCenterX = (leftPos + rightPos) / 2;
        const mapCenterY = (topPos + bottomPos) / 2;

        // Определяем радиус градиента, чтобы захватить всю карту
        const gradientRadius = Math.sqrt(Math.pow(rightPos - leftPos, 2) + Math.pow(bottomPos - topPos, 2)) / 2;

        // Создаем радиальный градиент, зафиксированный по карте
        const gradient = ctx.createRadialGradient(
            (mapCenterX - nodeX) * viewZoom + canvasWidth / 2, // Центр градиента по оси X
            (mapCenterY - nodeY) * viewZoom + canvasHeight / 2, // Центр градиента по оси Y
            0,                                                 // Начальный радиус градиента
            (mapCenterX - nodeX) * viewZoom + canvasWidth / 2, // Центр по X с учетом позиции игрока
            (mapCenterY - nodeY) * viewZoom + canvasHeight / 2, // Центр по Y с учетом позиции игрока
            gradientRadius * viewZoom                          // Радиус градиента
        );

        // Задаем цвета градиента
        gradient.addColorStop(0, "#132745");
        gradient.addColorStop(1, "#000000");

        // Заполняем холст градиентом
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    }

    // Старая версия сетки
function drawBlackGrid() {
    ctx.fillStyle = "#101010";
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    ctx.save();
    ctx.scale(viewZoom, viewZoom);
    const a = canvasWidth / viewZoom;
    const b = canvasHeight / viewZoom;

    // Устанавливаем цвет линий в белый
    ctx.strokeStyle = "white";
    ctx.globalAlpha = 0.1; // Увеличил alpha чтобы лучше было видно

    ctx.beginPath();
    for (let c = -.5 + (-nodeX + a / 2) % 50; c < a; c += 50) {
        ctx.moveTo(c, 0);
        ctx.lineTo(c, b);
    }
    ctx.stroke();

    ctx.beginPath();
    for (let c = -.5 + (-nodeY + b / 2) % 50; c < b; c += 50) {
        ctx.moveTo(0, c);
        ctx.lineTo(a, c);
    }
    ctx.stroke();
    ctx.restore();
}

function drawWhiteGrid() {
    ctx.fillStyle = "#F2FBFF";
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    ctx.save();
    ctx.scale(viewZoom, viewZoom);
    const a = canvasWidth / viewZoom;
    const b = canvasHeight / viewZoom;

    // Устанавливаем цвет линий в белый
    ctx.strokeStyle = "#111111";
    ctx.globalAlpha = 0.1; // Увеличил alpha чтобы лучше было видно

    ctx.beginPath();
    for (let c = -.5 + (-nodeX + a / 2) % 50; c < a; c += 50) {
        ctx.moveTo(c, 0);
        ctx.lineTo(c, b);
    }
    ctx.stroke();

    ctx.beginPath();
    for (let c = -.5 + (-nodeY + b / 2) % 50; c < b; c += 50) {
        ctx.moveTo(0, c);
        ctx.lineTo(a, c);
    }
    ctx.stroke();
    ctx.restore();
}


    // Инициализация изображений
    const innerImage = new Image();
    const centerBackground = new Image();
    centerBackground.src = "https://cdn.jsdelivr.net/gh/etoniko/agarsu/center.png"; // Фоновое изображение

    // Переменные для хранения данных топ-1 игрока
    let topPlayerNick = '';
    let topPlayerScore = 0;
    let topPlayerSkin = '';

    // Переменные для изменения размеров изображений
    let backgroundWidth = 512;  // Ширина фонового изображения
    let backgroundHeight = 512; // Высота фонового изображения
    let innerImageWidth = 450;  // Ширина скина игрока
    let innerImageHeight = 450; // Высота скина игрока

    // Функция для загрузки данных о топ-1 игроке
    function loadTopPlayerData(stat) {
        try {
            if (stat.length > 0) {
                const topPlayer = stat[0]; // Топ-1 игрок
                topPlayerNick = topPlayer.nick;
                topPlayerScore = topPlayer.score;

                const skinId = skinList[topPlayerNick];
                innerImage.src = skinId
                    ? `https://i.imgur.com/${skinId}.png`
                    : "https://i.imgur.com/PPFtwqH.png";

                topPlayerSkin = skinId || 'default';
            }
        } catch (error) {
            console.error('Ошибка обработки данных о топ-1 игроке:', error);
        }
    }

    // Загрузка изображений
    let isBackgroundLoaded = false;
    let isInnerImageLoaded = false;

    centerBackground.onload = function () {
        isBackgroundLoaded = true;
        console.log('Фоновое изображение загружено');
        drawCenterBackground();
    };

    innerImage.onload = function () {
        isInnerImageLoaded = true;
        console.log('Внутреннее изображение (скин игрока) загружено');
        drawCenterBackground();
    };

    function drawCenterBackground() {
        if (!isBackgroundLoaded || !isInnerImageLoaded) {
            return;
        }

        const mapCenterX = (leftPos + rightPos) / 2;
        const mapCenterY = (topPos + bottomPos) / 2;

        const screenX = (mapCenterX - nodeX) * viewZoom + canvasWidth / 2;
        const screenY = (mapCenterY - nodeY) * viewZoom + canvasHeight / 2;

        const scaledBackgroundWidth = backgroundWidth * viewZoom;
        const scaledBackgroundHeight = backgroundHeight * viewZoom;
        const scaledInnerImageWidth = innerImageWidth * viewZoom;
        const scaledInnerImageHeight = innerImageHeight * viewZoom;

        // Сначала рисуем внутреннее изображение (скин игрока) в виде круга
        ctx.save();
        const radius = Math.min(scaledInnerImageWidth, scaledInnerImageHeight) / 2; // Радиус круга

        // Создаём круг
        ctx.beginPath();
        ctx.arc(screenX, screenY, radius, 0, 2 * Math.PI);
        ctx.closePath();
        ctx.clip();

        ctx.drawImage(
            innerImage,
            screenX - scaledInnerImageWidth / 2,
            screenY - scaledInnerImageHeight / 2,
            scaledInnerImageWidth,
            scaledInnerImageHeight
        );

        ctx.restore();

        // Затем рисуем фон
        ctx.drawImage(
            centerBackground,
            screenX - scaledBackgroundWidth / 2,
            screenY - scaledBackgroundHeight / 2,
            scaledBackgroundWidth,
            scaledBackgroundHeight
        );

        // Устанавливаем стиль текста
        ctx.fillStyle = "white";
        ctx.font = `${22 * viewZoom}px Ubuntu`;
        ctx.textAlign = "center";

        ctx.fillText(topPlayerNick, screenX, screenY + radius - 415 * viewZoom);
        ctx.fillText(`${topPlayerScore}`, screenX, screenY + radius - 15 * viewZoom);
    }



    function drawSplitIcon(ctx) {
        var size = ~~(canvasWidth / 7);
        if (isTouchStart) {  // Проверяем, что экран был сенсорным
            // Анимация для кнопки "split"
            if (splitPressed && splitIcon.width) {
                ctx.save();
                ctx.scale(1.1, 0);
            }
            if (splitIcon.width) {
                ctx.drawImage(splitIcon, canvasWidth - size, canvasHeight - size, size, size);
            }
            if (splitPressed) {
                ctx.restore();
                setTimeout(() => splitPressed = false, 150);
            }

            // Анимация для кнопки "eject"
            if (ejectPressed && ejectIcon.width) {
                ctx.save();
                ctx.scale(1.1, 0); // Увеличиваем на 10% при нажатии
            }
            if (ejectIcon.width) {
                ctx.drawImage(ejectIcon, canvasWidth - size, canvasHeight - 2 * size - 20, size, size);
            }
            if (ejectPressed) {
                ctx.restore();
                setTimeout(() => ejectPressed = false, 150); // Восстановление после анимации через 150ms
            }
        }
    }
    function calcUserScore() {
        let score = 0;
        for (let i = 0; i < playerCells.length; i++) {
            score += playerCells[i].nSize * playerCells[i].nSize;
        }
        return score;
    }

    function drawLeaderBoard() {
        const leaderboardDiv = document.getElementById("leaderboard"); // Получаем div для отображения лидеров
        leaderboardDiv.innerHTML = ""; // Очищаем предыдущее содержимое

        // Проверяем, есть ли данные для отображения
        if ((teamScores && teamScores.length > 0) || (leaderBoard.length > 0)) {
            const header = document.createElement("h2");
            header.innerText = "Топ Сейчас"; // Заголовок
            leaderboardDiv.appendChild(header);

            const displayedPlayers = 10; // Лимит на отображение 10 игроков
            let myRank = null; // Переменная для хранения ранга текущего игрока

            if (!teamScores || teamScores.length === 0) {
                // Если не нужно отображать командные очки
                for (let b = 0; b < leaderBoard.length; ++b) {
                    let name = leaderBoard[b].name; // Имя игрока
                    const level = leaderBoard[b].level; // Level игрока
                    if (!showName) {
                        name = ""; // Если имя не отображается
                    }

                    const isMe = nodesOnScreen.indexOf(leaderBoard[b].id) !== -1; // Проверка, мой ли это игрок
                    if (isMe && playerCells[0]?.name) {
                        name = playerCells[0].name; // Если это я, используем моё имя
                        myRank = b + 1; // Сохраняем мой ранг
                    }

                    // Отображаем только первых 10 игроков
                    if (b < displayedPlayers) {
                        const entryDiv = document.createElement("div");
                        entryDiv.className = "Lednick"; // Добавляем класс Lednick
                        entryDiv.style.color = isMe ? "#FFAAAA" : "#FFFFFF"; // Цвет строки для isMe
                        entryDiv.innerHTML = (!noRanking ? `${b + 1}. ` : "") + (level !== -1 ? "<div class='star-container'><i class='fas fa-star'></i><span class='levelme'>" + level + "</span></div>" : "") + `<span>${name}</span>`; // Добавляем ранг
                        leaderboardDiv.appendChild(entryDiv); // Добавляем запись в leaderboardDiv
                    }
                }

                // Если мой ранг больше 10, показываем его на 11-й строке
                if (myRank && myRank > displayedPlayers) {
                    const level = accountData ? getLevel(accountData.xp) : -1;
                    const myRankDiv = document.createElement("div");
                    myRankDiv.className = "Lednick";
                    myRankDiv.style.color = "#FFAAAA"; // Цвет строки для isMe в 11-й позиции
                    myRankDiv.innerHTML = myRank + ". " + (level !== -1 ? "<div class='star-container'><i class='fas fa-star'></i><span class='levelme'>" + level + "</span></div>" : "") + `<span>${playerCells[0].name}</span>`; // Показываем мой ранг и имя
                    leaderboardDiv.appendChild(myRankDiv);
                }
            } else {
                // Если нужно отображать командные очки
                for (let b = 0; b < teamScores.length; ++b) {
                    const teamEntry = document.createElement("div");
                    teamEntry.innerText = `Team ${b + 1}: ${teamScores[b]}`; // Запись для команды
                    teamEntry.style.color = teamColor[b + 1]; // Цвет команды
                    leaderboardDiv.appendChild(teamEntry); // Добавляем запись в leaderboardDiv
                }
            }
        }
    }


    function Cell(uid, ux, uy, usize, ucolor, uname, a) {
        this.id = uid;
        this.ox = this.x = ux;
        this.oy = this.y = uy;
        this.oSize = this.size = usize;
        this.color = ucolor;
        this.points = [];
        this.pointsAcc = [];
        this.createPoints();
        this.setName(uname)
        this._skin = a;
    }

    function UText(usize, ucolor, ustroke, ustrokecolor) {
        usize && (this._size = usize);
        ucolor && (this._color = ucolor);
        this._stroke = !!ustroke;
        ustrokecolor && (this._strokeColor = ustrokecolor)
    }

    var nCanvas, ctx, mainCanvas, lbCanvas, chatCanvas, canvasWidth, canvasHeight, qTree = null,
        ws = null,
        nodeX = 0,
        nodeY = 0,
        nodesOnScreen = [],
        playerCells = [],
        nodes = {},
        nodelist = [],
        Cells = [],
        leaderBoard = [],
        chatBoard = [],
        rawMouseX = 0,
        rawMouseY = 0,
        X = -1,
        Y = -1,
        cb = 0,
        timestamp = 0,
        userNickName = null,
        leftPos = 0,
        topPos = 0,
        rightPos = 1E4,
        bottomPos = 1E4,
        foodMinSize = 0,
        foodMaxSize = 0,
        mapWidth = 0,
        mapHeight = 0,
        viewZoom = 1,
        showSkin = true,
        showName = true,
        // showColor = false,
        ua = false,
        // userScore = 0,
        showMass = true,
        hideChat = false,
        smoothRender = .4,
        posX = nodeX = ~~((leftPos + rightPos) / 2),
        posY = nodeY = ~~((topPos + bottomPos) / 2),
        posSize = 1,
        teamScores = null,
        ma = false,
        // hasOverlay = true,
        drawLine = false,
        lineX = 0,
        lineY = 0,
        drawLineX = 0,
        drawLineY = 0,
        // Ra = 0,
        teamColor = ["#333333", "#FF3333", "#33FF33", "#3333FF"],
        xa = false,
        zoom = 1,
        isTouchStart = "ontouchstart" in wHandle && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
        splitIcon = new Image,
        ejectIcon = new Image,
        noRanking = false;
    splitIcon.src = "https://i.imgur.com/b3KFHHK.png";
    ejectIcon.src = "https://i.imgur.com/RA4r3a0.png";
    // var wCanvas = document.createElement("canvas");
    // var playerStat = null;
    //wHandle.isSpectating = false;
    // Обновленный setNick
    wHandle.setNick = function (arg) {
        $('#overlays').hide();
        userNickName = arg;
        sendNickName();
        // userScore = 0;
    };
    wHandle.setSkins = function (arg) {
        showSkin = arg
    };
    wHandle.setNames = function (arg) {
        showName = arg
    };
    wHandle.setColors = function (arg) {
        // showColor = arg
    };
    wHandle.setShowMass = function (arg) {
        showMass = arg
    };
    wHandle.setSmooth = function (arg) {
        smoothRender = arg ? 2 : .4
    };
    wHandle.setChatHide = function (arg) {
        hideChat = arg;
        if (hideChat) {
            wjQuery('#chat_textbox').hide();
        } else {
            wjQuery('#chat_textbox').show();
        }
    }
    wHandle.spectate = function () {
        userNickName = null;
        // wHandle.isSpectating = true;
        // sendUint8(1);
        hideOverlays()
    };
    wHandle.setAcid = function (arg) {
        xa = arg
    };

    if (null != wHandle.localStorage) {
        wjQuery(window).load(function () {
            wjQuery(".save").each(function () {
                var id = $(this).data("box-id");
                var value = wHandle.localStorage.getItem("checkbox-" + id);
                if (value && value == "true" && 0 != id) {
                    $(this).prop("checked", "true");
                    $(this).trigger("change");
                } else if (id == 0 && value != null) {
                    $(this).val(value);
                }
            });
            wjQuery(".save").change(function () {
                var id = $(this).data('box-id');
                var value = (id == 0) ? $(this).val() : $(this).prop('checked');
                wHandle.localStorage.setItem("checkbox-" + id, value);
            });
        });
        if (null == wHandle.localStorage.AB8) {
            wHandle.localStorage.AB8 = ~~(100 * Math.random());
        }
    }

    // setTimeout(function () {
    // }, 3E5);
    // var T = {
    //     ZW: "EU-London"
    // };
    wHandle.connect = wsConnect;

    // var data = {
    //     "action": "test"
    // };
    var transparent = ["незнакомка","bublik"];
    var
        // delay = 500,
        oldX = -1,
        oldY = -1,
        // Canvas = null,
        z = 1,
        // scoreText = null,
        skins = {};
    // knownNameDict = "".split(";"),
    // knownNameDict_noDisp = [],
    // ib = ["_canvas'blob"]
    // ;
    Cell.prototype = {
        id: 0,
        points: null,
        pointsAcc: null,
        name: null,
        nameCache: null,
        sizeCache: null,
        x: 0,
        y: 0,
        size: 0,
        ox: 0,
        oy: 0,
        oSize: 0,
        nx: 0,
        ny: 0,
        nSize: 0,
        flag: 0,
        updateTime: 0,
        drawTime: 0,
        destroyed: false,
        isVirus: false,
        isEjected: false,
        isAgitated: false,
        wasSimpleDrawing: true,
        destroy: function () {
            var tmp;
            for (tmp = 0, len = nodelist.length; tmp < len; tmp++)
                if (nodelist[tmp] === this) {
                    nodelist.splice(tmp, 1);
                    break
                }
            delete nodes[this.id];
            tmp = playerCells.indexOf(this);
            if (-1 != tmp) {
                ua = true;
                playerCells.splice(tmp, 1);
            }
            tmp = nodesOnScreen.indexOf(this.id);
            if (-1 != tmp) nodesOnScreen.splice(tmp, 1);
            this.destroyed = true;
            Cells.push(this)
        },
        getNameSize: function () {
            return Math.max(~~(.3 * this.size), 24)
        },
        setName: function (a) {
            this.name = a;
            if (null == this.nameCache) {
                this.nameCache = new UText(this.getNameSize(), "#FFFFFF", true, "#000000");
                this.nameCache.setValue(this.name);
            } else {
                this.nameCache.setSize(this.getNameSize());
                this.nameCache.setValue(this.name);
            }
        },
        setSize: function (a) {
            this.nSize = a;
            var m = ~~(this.size * this.size * 0.01);
            if (null === this.sizeCache)
                this.sizeCache = new UText(this.getNameSize() * 0.5, "#FFFFFF", true, "#000000");
            else this.sizeCache.setSize(this.getNameSize() * 0.5);
        },
        createPoints: function () {
            for (var samplenum = this.getNumPoints(); this.points.length > samplenum;) {
                var rand = ~~(Math.random() * this.points.length);
                this.points.splice(rand, 1);
                this.pointsAcc.splice(rand, 1)
            }
            if (0 == this.points.length && 0 < samplenum) {
                this.points.push({
                    ref: this,
                    size: this.size,
                    x: this.x,
                    y: this.y
                });
                this.pointsAcc.push(Math.random() - .5);
            }
            while (this.points.length < samplenum) {
                var rand2 = ~~(Math.random() * this.points.length),
                    point = this.points[rand2];
                this.points.splice(rand2, 0, {
                    ref: this,
                    size: point.size,
                    x: point.x,
                    y: point.y
                });
                this.pointsAcc.splice(rand2, 0, this.pointsAcc[rand2])
            }
        },
        getNumPoints: function () {
            if (0 == this.id) return 16;
            var a = 10;
            if (20 > this.size) a = 0;
            if (this.isVirus) a = 30;
            var b = this.size;
            if (!this.isVirus) (b *= viewZoom);
            b *= z;
            if (this.flag & 32) (b *= .25);
            return ~~Math.max(b, a);
        },
        movePoints: function () {
            this.createPoints();
            for (var points = this.points, pointsacc = this.pointsAcc, numpoints = points.length, i = 0; i < numpoints; ++i) {
                var pos1 = pointsacc[(i - 1 + numpoints) % numpoints],
                    pos2 = pointsacc[(i + 1) % numpoints];
                pointsacc[i] += (Math.random() - .5) * (this.isAgitated ? 3 : 1);
                pointsacc[i] *= .7;
                10 < pointsacc[i] && (pointsacc[i] = 10);
                -
                    10 > pointsacc[i] && (pointsacc[i] = -10);
                pointsacc[i] = (pos1 + pos2 + 8 * pointsacc[i]) / 10
            }
            for (var ref = this, isvirus = this.isVirus ? 0 : (this.id / 1E3 + timestamp / 1E4) % (2 * Math.PI), j = 0; j < numpoints; ++j) {
                var f = points[j].size,
                    e = points[(j - 1 + numpoints) % numpoints].size,
                    m = points[(j + 1) % numpoints].size;
                if (15 < this.size && null != qTree && 20 < this.size * viewZoom && 0 != this.id) {
                    var l = false,
                        n = points[j].x,
                        q = points[j].y;
                    qTree.retrieve2(n - 5, q - 5, 10, 10, function (a) {
                        if (a.ref != ref && 25 > (n - a.x) * (n - a.x) + (q - a.y) * (q - a.y)) {
                            l = true;
                        }
                    });
                    if (!l && points[j].x < leftPos || points[j].y < topPos || points[j].x > rightPos || points[j].y > bottomPos) {
                        l = true;
                    }
                    if (l) {
                        if (0 < pointsacc[j]) {
                            (pointsacc[j] = 0);
                        }
                        pointsacc[j] -= 1;
                    }
                }
                f += pointsacc[j];
                0 > f && (f = 0);
                f = this.isAgitated ? (19 * f + this.size) / 20 : (12 * f + this.size) / 13;
                points[j].size = (e + m + 8 * f) / 10;
                e = 2 * Math.PI / numpoints;
                m = this.points[j].size;
                this.isVirus && 0 == j % 2 && (m += 5);
                points[j].x = this.x + Math.cos(e * j + isvirus) * m;
                points[j].y = this.y + Math.sin(e * j + isvirus) * m
            }
        },
        updatePos: function () {
            if (0 == this.id) return 1;
            var a;
            a = (timestamp - this.updateTime) / 120;
            a = 0 > a ? 0 : 1 < a ? 1 : a;
            var b = 0 > a ? 0 : 1 < a ? 1 : a;
            this.getNameSize();
            if (this.destroyed && 1 <= b) {
                var c = Cells.indexOf(this);
                -
                    1 != c && Cells.splice(c, 1)
            }
            this.x = a * (this.nx - this.ox) + this.ox;
            this.y = a * (this.ny - this.oy) + this.oy;
            this.size = b * (this.nSize - this.oSize) + this.oSize;
            return b;
        },
        shouldRender: function () {
            if (0 == this.id) {
                return true
            } else {
                return !(this.x + this.size + 40 < nodeX - canvasWidth / 2 / viewZoom || this.y + this.size + 40 < nodeY - canvasHeight / 2 / viewZoom || this.x - this.size - 40 > nodeX + canvasWidth / 2 / viewZoom || this.y - this.size - 40 > nodeY + canvasHeight / 2 / viewZoom);
            }
        },
        getStrokeColor: function () {
            var r = (~~(parseInt(this.color.substr(1, 2), 16) * 0.9)).toString(16),
                g = (~~(parseInt(this.color.substr(3, 2), 16) * 0.9)).toString(16),
                b = (~~(parseInt(this.color.substr(5, 2), 16) * 0.9)).toString(16);
            if (r.length == 1) r = "0" + r;
            if (g.length == 1) g = "0" + g;
            if (b.length == 1) b = "0" + b;
            return "#" + r + g + b;
        },
        drawOneCell: function (ctx) {
            if (this.shouldRender()) {
                var isSimpleRender = (this.id !== 0 && !this.isVirus && !this.isAgitated && smoothRender > viewZoom);
                if (this.getNumPoints() < 10) isSimpleRender = true;

                if (this.wasSimpleDrawing && !isSimpleRender) {
                    for (var i = 0; i < this.points.length; i++) {
                        this.points[i].size = this.size;
                    }
                }

                var bigPointSize = this.size;
                if (!this.wasSimpleDrawing) {
                    for (var i = 0; i < this.points.length; i++) {
                        bigPointSize = Math.max(this.points[i].size, bigPointSize);
                    }
                }

                this.wasSimpleDrawing = isSimpleRender;
                ctx.save();
                this.drawTime = timestamp;
                var scale = this.updatePos();
                if (this.destroyed) ctx.globalAlpha *= 1 - scale;

                ctx.lineWidth = 10;
                ctx.lineCap = "round";
                ctx.lineJoin = this.isVirus ? "miter" : "round";

                // Определение цвета и прозрачности
                var isTransparent = transparent.includes(this.name.toLowerCase());
                if (isTransparent) {
                    ctx.fillStyle = "rgba(0, 0, 0, 0)";
                    ctx.strokeStyle = "rgba(0, 0, 0, 0)";
                } else {
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = isSimpleRender ? this.color : this.getStrokeColor();
                }

                ctx.beginPath();
                if (isSimpleRender) {
                    var lw = this.size * 0.03;
                    ctx.lineWidth = lw;
                    ctx.arc(this.x, this.y, this.size - lw * 0.5 + 5, 0, 2 * Math.PI, false);
                } else {
                    this.movePoints();
                    var d = this.getNumPoints();
                    ctx.moveTo(this.points[0].x, this.points[0].y);
                    for (var i = 1; i <= d; ++i) {
                        var p = i % d;
                        ctx.lineTo(this.points[p].x, this.points[p].y);
                    }
                }
                ctx.closePath();

                // Определение ID скина через skinList
                var skinName = this.name.toLowerCase();
                var skinId = skinList[skinName];
                var skinImage = null;

                if (skinId) {
                    // Загружаем изображение скина только если ID найден в skinList
                    if (!skins.hasOwnProperty(skinId)) {
                        skins[skinId] = new Image();
                        skins[skinId].src = `https://i.imgur.com/${skinId}.png`;
                    }
                    if (skins[skinId].complete && skins[skinId].width > 0) {
                        skinImage = skins[skinId];
                    }
                }

                ctx.stroke();
                ctx.fill();

                // Отображение анимационного скина, если он загружен
                if (skinImage) {
                    ctx.save();
                    ctx.clip();

                    const frameWidth = skinImage.width; // Width of the sprite sheet
                    const frameHeight = skinImage.height; // Height of the sprite sheet

                    // Определение, является ли скин анимацией
                    if (frameWidth > frameHeight) {
                        // Это анимация
                        const totalFrames = Math.floor(frameWidth / frameHeight); // Total number of frames
                        const currentFrame = Math.floor((Date.now() / 100) % totalFrames); // Calculate current frame based on time

                        // Calculate source x position for the current frame
                        const sourceX = currentFrame * frameHeight;

                        // Draw the current frame
                        ctx.drawImage(skinImage, sourceX, 0, frameHeight, frameHeight,
                            this.x - bigPointSize, this.y - bigPointSize,
                            2 * bigPointSize, 2 * bigPointSize);
                    } else {
                        // Это статическое изображение
                        ctx.drawImage(skinImage, 0, 0, frameWidth, frameHeight,
                            this.x - bigPointSize, this.y - bigPointSize,
                            2 * bigPointSize, 2 * bigPointSize);
                    }

                    ctx.restore();
                }

// Отображение имени
                if (this.id !== 0) {
                    var x = Math.floor(this.x),
                        y = Math.floor(this.y),
                        nameSize = this.getNameSize(),
                        zoomRatio = Math.ceil(10 * viewZoom) * 0.1,
                        invZoomRatio = 1 / zoomRatio;


                    // Скрываем имя, если this.size > 100
                    if (showName && (this.name && this.nameCache) && this.size > 100) {
                        this.nameCache.setValue(this.name);
                        this.nameCache.setSize(nameSize);
                        this.nameCache.setScale(zoomRatio);
                        var nameImage = this.nameCache.render(),
                            nameWidth = Math.floor(nameImage.width * invZoomRatio),
                            nameHeight = Math.floor(nameImage.height * invZoomRatio);
                        ctx.drawImage(nameImage, x - Math.floor(nameWidth / 2), y - Math.floor(nameHeight / 2), nameWidth, nameHeight);
                    }

                    // Отображение массы
                    //скрываем массу если this.size > 100
                    if (showMass && ((!this.isVirus && !this.isEjected && !this.isAgitated) && this.size > 100)) {
                        var mass = Math.floor(this.size * this.size * 0.01);
                        this.sizeCache.setValue(mass);
                        this.sizeCache.setScale(zoomRatio);
                        var massImage = this.sizeCache.render(),
                            massWidth = Math.floor(massImage.width * invZoomRatio),
                            massHeight = Math.floor(massImage.height * invZoomRatio);
                        ctx.drawImage(massImage, x - Math.floor(massWidth / 2), y + Math.floor(massHeight * 0.8), massWidth, massHeight);
                    }
                }
                ctx.restore();
            }
        }

    };
    UText.prototype = {
        _value: "",
        _color: "#000000",
        _stroke: false,
        _strokeColor: "#000000",
        _size: 16,
        _canvas: null,
        _ctx: null,
        _dirty: false,
        _scale: 1,
        setSize: function (a) {
            if (this._size != a) {
                this._size = a;
                this._dirty = true;
            }
        },
        setScale: function (a) {
            if (this._scale != a) {
                this._scale = a;
                this._dirty = true;
            }
        },
        setStrokeColor: function (a) {
            if (this._strokeColor != a) {
                this._strokeColor = a;
                this._dirty = true;
            }
        },
        setValue: function (a) {
            if (a != this._value) {
                this._value = a;
                this._dirty = true;
            }
        },
        render: function () {
            if (null == this._canvas) {
                this._canvas = document.createElement("canvas");
                this._ctx = this._canvas.getContext("2d");
            }
            if (this._dirty) {
                this._dirty = false;
                var canvas = this._canvas,
                    ctx = this._ctx,
                    value = this._value,
                    scale = this._scale,
                    fontsize = this._size,
                    font = fontsize + 'px Ubuntu';
                ctx.font = font;
                var h = ~~(.2 * fontsize),
                    wd = fontsize * 0.1;
                var h2 = h * 0.5;
                canvas.width = ctx.measureText(value).width * scale + 3;
                canvas.height = (fontsize + h) * scale;
                ctx.font = font;
                ctx.globalAlpha = 1;
                ctx.lineWidth = wd;
                ctx.strokeStyle = this._strokeColor;
                ctx.fillStyle = this._color;
                ctx.scale(scale, scale);
                this._stroke && ctx.strokeText(value, 0, fontsize - h2);
                ctx.fillText(value, 0, fontsize - h2);
            }
            return this._canvas
        },
        getWidth: function () {
            return (ctx.measureText(this._value).width + 6);
        }
    };
    Date.now || (Date.now = function () {
        return (new Date).getTime()
    });
    var Quad = {
        init: function (args) {
            function Node(x, y, w, h, depth) {
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
                this.depth = depth;
                this.items = [];
                this.nodes = []
            }

            var c = args.maxChildren || 2,
                d = args.maxDepth || 4;
            Node.prototype = {
                x: 0,
                y: 0,
                w: 0,
                h: 0,
                depth: 0,
                items: null,
                nodes: null,
                exists: function (selector) {
                    for (var i = 0; i < this.items.length; ++i) {
                        var item = this.items[i];
                        if (item.x >= selector.x && item.y >= selector.y && item.x < selector.x + selector.w && item.y < selector.y + selector.h) return true
                    }
                    if (0 != this.nodes.length) {
                        var self = this;
                        return this.findOverlappingNodes(selector, function (dir) {
                            return self.nodes[dir].exists(selector)
                        })
                    }
                    return false;
                },
                retrieve: function (item, callback) {
                    for (var i = 0; i < this.items.length; ++i) callback(this.items[i]);
                    if (0 != this.nodes.length) {
                        var self = this;
                        this.findOverlappingNodes(item, function (dir) {
                            self.nodes[dir].retrieve(item, callback)
                        })
                    }
                },
                insert: function (a) {
                    if (0 != this.nodes.length) {
                        this.nodes[this.findInsertNode(a)].insert(a);
                    } else {
                        if (this.items.length >= c && this.depth < d) {
                            this.devide();
                            this.nodes[this.findInsertNode(a)].insert(a);
                        } else {
                            this.items.push(a);
                        }
                    }
                },
                findInsertNode: function (a) {
                    return a.x < this.x + this.w / 2 ? a.y < this.y + this.h / 2 ? 0 : 2 : a.y < this.y + this.h / 2 ? 1 : 3
                },
                findOverlappingNodes: function (a, b) {
                    return a.x < this.x + this.w / 2 && (a.y < this.y + this.h / 2 && b(0) || a.y >= this.y + this.h / 2 && b(2)) || a.x >= this.x + this.w / 2 && (a.y < this.y + this.h / 2 && b(1) || a.y >= this.y + this.h / 2 && b(3)) ? true : false
                },
                devide: function () {
                    var a = this.depth + 1,
                        c = this.w / 2,
                        d = this.h / 2;
                    this.nodes.push(new Node(this.x, this.y, c, d, a));
                    this.nodes.push(new Node(this.x + c, this.y, c, d, a));
                    this.nodes.push(new Node(this.x, this.y + d, c, d, a));
                    this.nodes.push(new Node(this.x + c, this.y + d, c, d, a));
                    a = this.items;
                    this.items = [];
                    for (c = 0; c < a.length; c++) this.insert(a[c])
                },
                clear: function () {
                    for (var a = 0; a < this.nodes.length; a++) this.nodes[a].clear();
                    this.items.length = 0;
                    this.nodes.length = 0
                }
            };
            var internalSelector = {
                x: 0,
                y: 0,
                w: 0,
                h: 0
            };
            return {
                root: new Node(args.minX, args.minY, args.maxX - args.minX, args.maxY - args.minY, 0),
                insert: function (a) {
                    this.root.insert(a)
                },
                retrieve: function (a, b) {
                    this.root.retrieve(a, b)
                },
                retrieve2: function (a, b, c, d, callback) {
                    internalSelector.x = a;
                    internalSelector.y = b;
                    internalSelector.w = c;
                    internalSelector.h = d;
                    this.root.retrieve(internalSelector, callback)
                },
                exists: function (a) {
                    return this.root.exists(a)
                },
                clear: function () {
                    this.root.clear()
                }
            }
        }
    };

    const onLogout = () => {
        if (confirm("Ты действительно хочешь выйти из учетной записи?")) {
            /*wHandle.*/userXP.textContent = /*wHandle.*/userLevel.textContent = "";
            accountData = null;
            clearAccountToken();

            /*wHandle.*/logoutButton.style.display = "none";
            /*wHandle.*/loginButton.style.display = "";
        }
    };

    wHandle.logoutAccount = async () => {
        if (localStorage.accountToken) {
            const res = await accountApiGet("me/logout");
            if (res.ok) {
                const data = await res.json();
                if (data.ok || 401 == data.status) onLogout();
                if (data.error) alert(data.error);
            }
        }
        else onLogout();
    }

    // wHandle.openLoginAccountWith = name => {
    //     /*wHandle.*/open("/api/login/" + name, "", "width=400, height=500");
    //     const listener = evt => {
    //         /*wHandle.*/removeEventListener("message", listener);
    //         onAccountLoggedIn(evt.data.token);
    //     }
    //     /*wHandle.*/addEventListener("message", listener);
    // };

    wHandle.onUloginToken = async tokenUlogin => {
        // /*wHandle.*/open("/auth/ulogin/?token=" + tokenUlogin, "", "width=400, height=500");
        const res = await accountApiGet("auth/ulogin?token=" + tokenUlogin);
        if (res.ok) {
            const data = await res.json();
            if (data.error) alert(data.error);
            else onAccountLoggedIn(data.token);
        }
    };

    const setAccountToken = token => {
        /*wHandle.*/localStorage.accountToken = token;
    };

    const clearAccountToken = () => {
        delete /*wHandle.*/localStorage.accountToken;
    };

    const accountApiGet = tag => fetch("https://itana.pw:6003/api/" + tag, { headers: { Authorization: `Game ${/*wHandle.*/localStorage.accountToken}` } });

    wHandle.onAccountLoggedIn = token => {
        setAccountToken(token);
        loadAccountUserData();
        sendAccountToken();
    };

    let accountData;

    const setAccountData = data => {
        accountData = data;
        displayAccountData();
        document.querySelectorAll(".menu-item")[2].click(); // На главную меню

        /*wHandle.*/logoutButton.style.display = "";
        /*wHandle.*/loginButton.style.display = "none";
    };

    const loadAccountUserData = async () => {
        const res = await accountApiGet("me/login");
        if (res.ok) {
            const data = await res.json();
            if (data.error) {
                if (401 == data.status) clearAccountToken();
                else alert(data.error);
            }
            else setAccountData(data);
        }
    };

    if (/*wHandle.*/localStorage.accountToken) loadAccountUserData();

    const getXp = level => ~~(100 * (level ** 2 / 2));
    const getLevel = xp => ~~((xp / 100 * 2) ** .5);

    const displayAccountData = () => {
        const currLevel = getLevel(accountData.xp); // Получаем текущий уровень
        const nextXp = getXp(currLevel + 1); // Получаем XP для следующего уровня
        const progressPercent = (accountData.xp / nextXp) * 100; // Рассчитываем процент прогресса

        // Обновляем текст с XP
        const userXPElement = document.getElementById("userXP")?.querySelector(".status-value");
        if (userXPElement) {
            userXPElement.textContent = `${accountData.xp}/${nextXp}`;
        }

        // Обновляем текст с уровнем
        const userLevelElement = document.getElementById("userLevel")?.querySelector(".status-value");
        if (userLevelElement) {
            userLevelElement.textContent = currLevel;
        }

        // Обновляем прогресс бар
        const progressBar = document.querySelector(".progress-fill");
        if (progressBar) {
            progressBar.style.width = `${progressPercent}%`;
        }

        // Обновляем круг с уровнем
        const levelCircle = document.getElementById("levelCircle");
        if (levelCircle) {
            levelCircle.textContent = currLevel;
        }

        // Обновляем текст с прогрессом
        const progressText = document.getElementById("progressText");
        if (progressText) {
            progressText.textContent = `${Math.round(progressPercent)}% (${accountData.xp}/${nextXp})`;
        }

        // Отображаем account_id, если элемент существует
        const accountIDElement = document.getElementById("accountID");
        if (accountIDElement) {
            accountIDElement.textContent = `ID: ${accountData.uid}`;
        }
    };




    const onUpdateXp = xp => {
        if (accountData) {
            accountData.xp = xp;
            displayAccountData();
        }
    };

    wHandle.onload = gameLoop;
})(window, window.jQuery);
</script>
</html>
